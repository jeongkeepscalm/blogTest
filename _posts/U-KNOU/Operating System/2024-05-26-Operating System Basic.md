---
title: "[U-KNOU] 운영체제"
description: "[U-KNOU] 운영체제"
date: 2024-05-26
categories: [ U-KNOU, Operating System ]
tags: [ U-KNOU, Operating System ]
---

## 운영체제란?

- 대표적인 시스템 소프트웨어  
- 컴퓨터 시스템의 자원을 관리하고 프로그램 동작을 위한 서비스를 제공하는 프로그램들의 모음  

### 운영체제의 역할

1. 컴퓨터 시스템의 자원 관리  
  - 저장장치에서 데이터 읽어오기  
  - CPU와 메모리를 효율적으로 관리  
2. 사용자 지원  
  - 사용자가 내린 명령을 해석 후 실행
  - 편의성 제공  

<br/>
<hr>

```운영체제가 없던 초기 컴퓨터 시스템```  
- 응용프로그램이 하드웨어를 직접 제어  
- 응용프로그램 개발자는 하드웨어 제어 방법을 잘 알아야 했음  
```운영체제가 있는 컴퓨터 시스템```  
- **하드웨어와 응용프로그램의 매개체**  
- **운영체제가 컴퓨터 시스템의 자원 제어**  
  
```커널모드(슈퍼바이저 모드)```: 하드웨어를 직접 제어할 수 있는 CPU 명령어를 사용할 수 있는 모드  
```사용자모드(보호 모드)```: CPU 명령어를 사용할 수 없고 응용프로그램이 동작하는 모드  
  
```커널(Kernel)```  
- 커널 모드에서 동작하는 운영체제의 핵심 요소  
- 응용프로그램과 하드웨어 수준의 처리사이의 가교 역할  

<br/>

```일체형커널```( 커널 == 운영체제 )  
- 운영체제의 모든 서비스가 커널 내 포함  
- 커널 내부 요소들의 효율적으로 상호작용  
- 한 요소라도 오류가 발생하면 시스템 전체에서 장애 발생 가능 ( UNIX, Linux.. )  
```마이크로커널```   
- 커널 안에는 가장 핵심적인 요소들만 있다. ( 메모리 관리, 멀티태스킹, 프로세스 간 통신(IPC) 등.. )  
- 새로운 서비스를 추가하여 운영체제를 확장하기 쉽다.  
- 유지보수가 용이하여 안정성이 우수하다.   
- 커널 외부 요소들 사이는 IPC가 필요하여 성능저하가 발생한다.  

<br/>

```시스템 호출```  
- 응용프로그램이 하드웨어에 대한 제어가 필요할 때 이용한다.  
- 운영체제에 서비스를 요청하는 메커니즘  

### 운영체제 구성

```프로세스 관리자```  
- 프로세스의 생성 및 삭제  
- CPU 할당을 위한 스케줄 결정  
- 메모리에 올라와있는 프로그램의 순서를 스케줄링이 결정  
- 프로세스의 상태를 관리하며 상태 전이 처리  
```메모리 관리자```  
- 메모리 공간을 보호  
- 차지하고 있는 메모리와 겹치지 않게 메모리 공간을 부여해서 할당 및 회수  
```장치 관리자```  
- 컴퓨터 시스템의 모든 장치에 할당, 작동, 반환해준다. ( 하드 디스크, SSD, 키보드, 마우스, 프린터 등.. )  
```파일 관리자```  
- 저장장치의 공간 관리  
- 파일의 접근 제한 관리  

### 운영체제의 유형

```일괄처리 운영체제(Batch Processing)```  
- 작업을 모아서 순서대로 처리하는 방식  
- 전체적인 작업 처리 속도가 향상됨  
- 나중에 들어온 중요도 높은 작업은 우선순위에 밀려 기다리게 된다.  
```시분할 운영체제(Time Sharing)```  
- 각 프로그램을 한 번에 조금씩 수행하는 방식  
- 응답시간이 일괄처리 운영체제보다 크게 단축된다.  
```실시간 운영체제(Real-Time)(RTOS)```  
- 원하는 시간 내에 프로그램 결과를 얻을 수 있는 방식  
- 최종적인 결과물을 받는 시간이 빠름  
- 처리결과가 현재의 결정에 영향을 주는 환경에서 사용(미사일 제어 시스템, 증권 거래 관리 시스템 등..)  
```분산 운영체제```
- 분산 시스템을 관리하기 위한 운영체제  
- 분산 시스템: 2개 이상의 컴퓨터 시스템이 네트워크로 서로 연결되어 서로의 자원을 이용하는 시스템  
- 다른 컴퓨터 시스템의 자원을 이용하는 것이 마치 자신 컴퓨터 시스템에 있는 자원을 이용하는 것처럼 가능하게 한다.  

<br/>
<hr>

## 프로세스란?

- 실행중인 프로그램   
- 동작을 하는 능동적 개체   
- 운영체제로부터 자원을 할당 받아 동작   

### 운영체제(프로세스 관리자)가 처리하는 작업

- 프로세스를 생성 및 종료  
- 프로세스를 실행시키기 위한 스케줄링 작업  
- 프로세스의 상태 관리  
  
<img src="/assets/img/os.jpg" width="600px">  
  
```프로세스 제어 블록(PCB: Process Control Block)```: 운영체제가 프로세스를 관리하기 필요한 정보를 가지고 있다.  
- 프로세스번호(PID)  
- 프로세스 상태  
- 프로그램 카운터(PC): 다음에 어떤 처리를 해야 하는지 알 수 있다. 제어의 흐름을 볼 수 있다.    
- 레지스터: 여러 프로세스가 번갈아 실행되는 경우 레지스터에 저장되어 있던 값을 활용한다.  
- 메모리 관리 정보  
- 프로세스 우선순위  
- 회계 정보 ...  

### 프로세스 상태 

<img src="/assets/img/processState.jpg" width="600px">  
  
```디스패치```: 프로세스를 CPU에 할당하는 과정  

<br/>

**프로세스 생성과정**  
- 사용자가 직접 프로그램 실행  
- 한 프로세스가 다른 프로세스를 생성(부모프로세스가 자식프로세스 생성): 프로세스 생성 시스템 호출 이용  
  
**프로세스 종료 방법**  
- 프로세스가 모든 처리를 완료할 때( 정상적 종료 )  
- 부모프로세스가 자식프로세스를 강제 종료할 수 있다.      
- 자식의 PID를 이용해서 프로세스 종료 시스템 호출한다.  

### 쓰레드란?

- 프로세스 내에 다중처리를 위해 제안된 개념  
- 디스패칭의 단위
- 하나의 프로세스에는 하나 이상의 쓰레드가 존재한다.  
- 전통적인 프로세스와는 다르게 쓰레드가 PC(program counter)를 가지고 있다.  
- 실행에 필요한 최소한의 정보만 가진다.  
    - PC를 포함한 레지스터 값  
    - 상태정보  
    - 스택 영역  
    - 나머지 정보는 프로세스에 두고 다른 쓰레드와 공유  
  
<img src="/assets/img/processInner.jpg" width="600px">  

<br/>
<hr>

## 스케줄링

```스케줄링```: 여러가지 작업의 처리 순서를 결정  

<br/>

- 프로세스 스케줄링
- 디스크 스케줄링  
  
**스케줄링의 기본 목표**   
- 공정성: 모든 프로세스가 적정 수준에서 CPU 작업을 할 수 있게 함.  
- 균형: 시스템 자원이 충분히 활용될 수 있게 함.  
  
**운영체제 유형에 따른 스케줄링의 목표**  
- 일괄처리 운영체제: 처리량 극대화, 반환시간(프로세스 생성~종료) 최소화, CPU활용 극대화.  
- 시분할 운영체제: 빠른 응답시간, 과다한 대기시간 방지.  
- 실시간 운영체제: 처리기간 맞춤.  
  
**선점 스케줄링 정책(preemptive)**
- 높은 우선순위의 프로세스를 바로 처리할 수 있다. (실시간 시스템, 시분할 시스템)  
- 문맥교환에 따른 오버헤드가 발생  
- ```문맥(context)```: CPU의 모든 레지스터와 기타 운영체제에 따라 요구되는 프로세스 상태  
- ```문맥교환(context switching)```: 현재 프로세스의 문맥을 PCB에 저장하고 다른 프로세스의 PCB를 읽어 문맥을 복원하는 작업이다.  
- ```오버헤드```: 추가적으로 시간, 메모리, 자원이 사용되는 현상   
  
**비선점 스케줄링 정책(nonpreemptive)**  
- 실행 중인 프로세스를 바로 준비 상태로 문맥교환을 할 수 없다. ( 실행 -> 종료 / 실행 -> 대기 (o) )  
- 강제적인 문맥교환이 없기에 오버헤드가 없다.   

### 스케줄링 알고리즘

**FCFS(First-Come First-Served)**  
- 비선점 방식
- 준비 큐에 도착한 순서에 따라 디스패치.  
- 프로세스의 도착 순서에 따라 반환시간이 크게 변한다.  
  
**SJF(Shortest Job First)**   
- 비선점 방식  
- 준비 큐 내 프로세스 중 가장 짧은 실행시간으로 예상되는 프로세스를 먼저 디스패치한다.  
- 일괄처리 환경에서 구현하기 쉽다.  
  
**SRT(Shortest Remaining Time)**  
- 선점방식  
- SJF보다 평균대기시간이나 평균반환시간에 효율적  
  
**RR(Round Robin)**  
- 선점방식  
- FCFS처럼 먼저 도착한 순서대로 디스패치 하지만, 정해진 시간할당량이 주어지고 시간할당량 내 종료하지 못한 프로세스는 준비큐의 마지막에 배치된다.  
- CPU를 독점하지 않고 공평하게 이용한다.(시분할 운영체제에 적합)  
- 시간 할당량이 너무 크면, FCFS와 다를 바 없다.  
  
**HRN(Highest Response Ratio Next)**  
- 비선점방식  
- 준비큐에서 기다리는 프로세스 중 응답비율이 가장 큰 것을 먼저 디스패치한다.  
  
**다단계 피드백 큐 스케줄링**  
- 선점 방식  
- I/O 중심 프로세스와 연산 중심 프로세스의 특성에 따라 **서로 다른 시간 할당량 부여**  
- 1 ~ n 단계까지 준비큐 존재  
- 1단계 준비큐에 프로세스가 다 실행되고 종료되지 못한 프로세스들은 2단계 준비큐로 넘어가게 되고 ... n단계 준비큐까지 이어진다.  
- 단계가 커질수록 시간 할당량도 커진다.  
- I/O 중심 프로세스에 높은 우선권이 유지된다.  
- 연산 중심 프로세스는 낮은 우선권을 갖지만 긴 시간 할당량을 갖는다.  
  
<img src="/assets/img/sun.jpg" width="600px">  

<br/>
<hr>

## 병행 프로세스

병행성: 여러 프로세스/쓰레드가 동시에 수행되는 시스템 특성  
  
- CPU가 1개 일 경우(인터리빙 형식)  
  여러 프로세스가 실행될 수는 있지만 CPU에서의 처리는 한 프로세스만 처리하고 있다. (RR스케줄링과 비슷하게 처리)  
- CPU가 여러 개일 경우(병렬처리 형식)  
  CPU의 개수만큼 프로세스 동시에 처리 가능하다.  
  => 즉, 하나의 CPU는 하나의 프로세스만 처리할 수 있다.  
  
- 강결합 시스템  
  여러 CPU들이 하나의 메모리를 공유한다.(공유 메모리 구조)  
- 약결합 시스템  
  CPU 마다 메모리가 별도로 존재한다.(분산 메모리 구조)  
  CPU끼리 정보를 주고 받을 때, 통신선을 통한다.  
  
- 독립 프로세스  
  - 각각의 프로세스가 자신의 일만 한다. 다른 프로세스에 영향을 주고 받지 않는다.  
  - 데이터 및 상태를 다른 프로세스들과 공유하지 않는다.  
  - 결정적. **실행 결과는 입력에 의해서 결정**된다.  
  - 재생가능. 같은 입력에 대하여 항상 같은 실행결과를 리턴한다.  
- 협력 프로세스  
  - 수행중인 다른 프로세스와 영향을 주고 받는다.  
  - 데이터 및 상태를 다른프로세스들과 공유한다.  
  - 비결정적. 실행결과는 실행순서에 좌우된다.  
  - 재생불가능. 같은 입력에 대하여 항상 같은 실행결과를 보장할 수 없다.  
  
- 협력 프로세스일 경우 생기는 문제  
  1. 상호배제 필요
    2개 이상의 프로세스가 동시에 **임계영역을 수행하지 못하도록** 해야한다.  
    `임계영역`: 두 개 이상의 프로세스가 동시에 공유 자원에 접근을 허용하는 프로그램 코드 영역  
  2. 동기화 필요  
    2개 이상의 프로세스들의 처리 순서를 결정해야 한다.  
  3. 통신 필요  
    프로세스들이 데이터를 공유하기 위해 반드시 필요하다.  

<br/>

`세마포어(정수형 공용 변수)`  
- **상호배제와 동기화 문제를 해결할 수 있는 도구**  
- Dijkstra가 제안.  
- 임계변수에 들어갈 수 있는 여부에 따른 정수값 혹은 사용 가능한 자원의 수를 공용변수로 저장할 수 있다.  
- 상황에 맞춰 0 이상인 정수로 초기화한다.  
- 두 기본연산 p와 v에 의해서만 사용된다. 기본연산은 중간에 중단되지 않고 하나의 단위로 처리된 후에 다음 작업을 한다.  
  
- 연산 p: 감소연산  

```java
void p(semaphore s) {
	if (s > 0) {
		s--;
    } else {
        현재 프로세스를 대기시킨다.
    }
}
```

- 연산 v: 증가연산  

```java
void v(semaphore s) {
	if (대기 중인 프로세스가 없음) {
		s++;
    } esle {
        대기 중인 프로세스 1개를 진행시킨다. 
    }
}
```
  
- 두 협력 프로세스 사이에 버퍼를 두고 생산자와 소비자의 상황을 다룬다.  
  생산자: 데이터를 버퍼에 넣음.   
  소비자: 데이터를 버퍼에서 꺼냄.  
  버퍼: 임시 저장 공간.  
  
버퍼에 여러 프로세스가 동시에 접근할 수 없다.  
데이터를 버퍼에 넣을 동안 버퍼에서 데이터를 꺼낼 수 없다.  
버퍼에서 데이터를 꺼낼 동안 데이터를 버퍼에 넣을 수 없다.  
  
- 유한 버퍼 문제  
버퍼의 크기가 유한하다.  
버퍼가 가득 찬 경우, 생산자는 대기해야한다.  
버퍼가 비어 있을 경우, 소비자는 대기해야한다.  
  
- 여러 협력 프로세스 사이에 공유 자원을 두고 판독기와 기록기의 상황을 다루는 문제  
  판독기: 데이터를 읽는 프로세스  
  기록기: 데이터를 쓰는 프로세스  
  
하나의 기록기가 공유자원에 데이터를 쓰는 중에는, 다른 기록기/판독기는 공유자원에 접근 할 수 없다.  
공유자원에 데이터를 쓰고 있을 동안에는 누구도 공유자원에 접근할 수 없다.  
공유자원의 데이터를 읽고 있을 동안에는 누구도 공유자원에 데이터를 쓸 수 없다.  
  
- 제1판독기: 판독기 우선, 기록기 기아상태 유발 가능    
- 제2판독기: 대기 중인 기록기에 우선순위를 준다. 판독기 기아상태 유발 가능    

<br/>

`기아상태`: 실행될 가능성은 있지만 기한없이 기다려야 되는 상태  

### 프로세스 간 통신(IPC: InterProcess Communication)  

- 병행 프로세스가 데이터를 서로 공유하는 방법  
  - 공유 메모리 방법  
    - 협력 프로세스가 공유 메모리 공간을 활용하여 동일한 변수를 사용한다.  
    - 대량 데이터 교환이 편하다. (고속 통신 가능)  
    - 공유 메모리를 공유했을 시 발생하는 문제점을 프로그래머들이 다 해결을 해주어야 한다.  
  - 메시지 전달 방법  
    - 시스템호출 send( ), receive( ) 사용  
    - send( ) 함수를 통해 커널로 전달 후 커널이 receive( ) 를 이용해 전달한다.  
    - 소량 데이터 교환에 적합하다.  
    - 메시지 전달로 인해 발생한 문제는 운영체제가 해결한다.  
    - 통신 링크 : 메시지가 지나다니는 통로  
  
직접통신  
  - 두 프로세스가 직접 서로를 지정하여 메시지를 전달한다.    
  - 통신 링크가 하나만 자동으로 설정된다.    
  - 양방향의 통신링크를 가진다.    
  - 대칭형 주소 지정 : 프로세스명을 직접 지정해서 통신한다.    
  - 비대칭형 주소 지정 : 변수를 매개변수로 사용해서 통신한다.    

간접통신  
- 두 프로세스 사이에 둔 우편함을 통해 메시지를 전달한다.  
- 같은 우편함을 이용하는 경우 통신 링크가 설정  
- 여러 우편함을 이용하면 여러 개의 통신 링크 존재  
- 하나의 통신 링크가 여러 프로세스와 연관 가능  
- 통신 링크는 단방향/양방향  

<br/>
<hr>

## 교착상태

- 프로세스의 자원 사용 절차  
  요구 -> 사용 -> 해제    
  요구과정에서 가용한 자원이 없으면 자원을 획득할 때까지 대기  

<br/>

`교착상태`  
- 여러 개의 프로세스가 서로 상대방의 작업을 끝나기만 기다리고 있어 어느 쪽도 영원히 진행하지 못하는 상태  
  
**교착상태의 필요조건**(4가지 조건을 동시에 만족한다고 해서 교착상태에 빠지는 건 아님)
- 상호배제
- 점유대기
- 비선점
- 환형대기  
  
**자원할당 그래프 G = (V , E)**
- V: 정점의 집합 = P U R (프로세스 집합과 자원의 집합 관계)  
- E: 방향이 있는 간선의 집합 = Q U S (프로세스와 자원과의 관계)   
    - Q: 요구간선  
    - S: 할당간선  
  
교착상태의 처리기법  
1. 교착상태 예방  
  - 상호배제 조건 제거
  - 점유대기 조건 제거
  - 비선점 조건 제거 
  - 환형대기 조건 제거 
2. 교착상태 회피  
  - 안전상태: 교착상태 빠질 가능성 없다. 안전순서열 존재  
  - 불안전상태: 교착상태 빠질 가능성 있다. 안전순서열 미존재  
  - `안전순서열`: 순서있는 프로세스의 집합 < p1, p2, p3, … pn > 
  - 교착상태 회피 알고리즘  
    - 변형된 자원할당 그래프(각 자원의 단위 자원이 하나인 경우)
    - 은행원 알고리즘(각 자원의 단위 자원이 여러 개 경우)
3. 교착상태 탐지 및 복구  
  - Shoshani/Coffman 교착상태 알고리즘으로 교착상태 탐지한다.  
  - 교착상태 복구 방법
    - 교착상태 프로세스를 종료
    - 교착상태 프로세스가 할당받은 자원을 해제

<br/>
<hr>

## 메모리 관리

- 프로세스의 동작
  PC: 프로그램 카운터(주소 값)를 참조하여 수행될 명령을 메모리에 읽어 CPU로 수행하는 것  
  
<img src="/assets/img/memory.jpg" width="600px">  
  
- 단일 프로그래밍 환경  
  - 하나의 프로세스만 메모리를 전용으로 사용하는 것
  - 메모리의 용량을 초과하는 프로세스는 실행 못한다.  
  - 주변장치 등 자원의 낭비가 심하다.  
- 다중 프로그래밍 환경
  - 여러 개의 프로세스가 메모리에 동시에 적재되는 것
  - CPU 연산과 입출력을 동시에 함으로써 CPU 이용도와 시스템 처리량 증가  
  
- 메모리 분할: 여러 프로세스를 메모리에 적재하기 위해 고안된 방법   
  - 고정 분할  
    메모리에 여러 개의 고정된 크기의 영역을 분할  
  - 동적 분할  
    메모리의 분할경계가 고정되지 않음  
    각 프로세스에 필요한 만큼의 메모리만 할당  
    통합: 인접된 공백을 더 큰 하나의 공백으로 만들어 외부 단편화 해결  
    집약: 메모리 내의 모든 공백을 하나로 모아 외부단편화 해결  
  
- 메모리 보호  
  - 프로세스가 다른 할당영역을 침범하지 않게 하는 것  
  - 하한-상한 / 하한-크기 레지스터 쌍으로 제한 (범위 제한)  
    (b보다 작은 / c보다 큰 영역에 침범을 막는다)  
  - 이 제한 넘어 운영체제를 호출하려면 시스템 호출을 이용한다  
  
- 메모리 배치기법
  - 최초 적합: 사용 가능한 빈 공간 중에서 가장 먼저 발견되는 곳을 할당  
  - 후속 적합: 이전에 탐색이 끝난 그 다음 부분부터 시작하여 사용 가능한 빈 공간 중에서 가장 먼저 발견되는 곳을 할당  
  - 최적 적합: 필요한 공간을 제공할 수 있는 빈 공간 중 가장 작은 곳을 선택하여 할당  
  - 최악 적합: 필요한 공간을 제공할 수 있는 빈 공간 중 가장 큰 곳을 선택하여 할당  

<br/>
<hr>

## 가상 메모리

- 실행 중인 프로세스에 의해 참조되는 주소를 메모리에서 사용하는 주소와 분리
- 현재 필요한 일부만 메모리에 적재  
  
- 사상(mapping)  
  프로세스 실행을 위해 가상주소를 실주소로 변환하는 과정  
  동적 주소변환(DAT: Dynamic Address Translation): 프로세스가 실행되는 동안 사상  

<br/>

`주소변환 기법`인 `사상표`를 이용하여 가상주소 공간과 실주소 공간을 매핑 시킨다.  

<br/>

- 블록 사상 시스템    
  - 블록 단위로 주소 변환  
  - 가상 메모리의 각 블록이 메모리의 어디에 위치하는지 관리  
  - 가상주소 v = (b, d): b블록 내 d 거리 떨어진 주소에 v가 존재  
  
- **블록 구성방식**
  - `페이징`: 블록크기 동일  
    - 직접사상에 의한 동적 주소변환: 페이지 사상표 직접 이용  
    - 연관사상에 의한 동적 주소변환: 페이지 변환 정보를 연관 메모리에 저장한 연관사상표를 이용    
  - `세그먼트`: 블록크기 다를 수 있음, 논리적 의미에 부합하는 다양한 크기의 블록    
  
- 페이지 기법의 특징  
  - 논리적 의미와 무관한 동일 크기의 페이지로 나눔
  - 메모리 보호는 페이지 단위로 이루어짐
  - 외부 단편화 발생하지 않는다.
  - 내부 단편화 발생 가능하다.  
  
- 세그먼테이션 기법: 가상 메모리를 세그먼트 단위로 나누어 관리하는 기법  
  
- 페이징/세그먼테이션 혼용기법
  - 세그먼테이션 기법의 논리적 장점 + 페이징 기법의 메모리 관리 측면의 장점
  - 가상 메모리를 세그먼트 단위로 분할 후 각 세그먼트를 다시 페이지 단위로 분할  
  
- 메모리 호출기법  
  - 요구 페이지 호출 기법
    - 옮길 페이지 결정에 대한 오버헤드 최소화
    - 적재된 페이지는 실제로 참조됨
    - 프로세스 시작 시점에는 연속적으로 페이지 부재 발생
  - 예상 페이지 호출 기법
    - 예상이 잘못된 경우 시간과 메모리 공간 낭비
    - 프로세스 시작 시점에 적용하면 성능이 개선됨  

<br/>
<hr>

## 페이지 교체 알고리즘

- 최적화 원칙으로 교체 
- 선택을 위한 기본 정책
- 교체 제외 페이지 선택
  - 페이징을 위한 커널 코드 영역
  - 보조기억장치 드라이버 영역
  - 시간을 맞춰 동작해야 하는 코드 영역
  - 입출력장치를 위한 데이터 버퍼 영역 등
  
**페이지 교체 알고리즘**
- FIFO 페이지 교체(First In First Out)  
  - Queue 이용, 메모리에 가장 오래 있었던 페이지 교체, Belady 이상현상  
  - 프로세스에 더 많은 수의 페이지 프레임을 할당하면 오히려 페이지 부재가 더 많이 발생할 수 있는 현상  
- LRU 페이지 교체(Least Recently Used)  
  - 메모리 내 가장 오랫동안 사용되지 않은 페이지를 선택하여 교체  
  - 막대한 오버헤드  
- LFU 페이지 교체(Least Frequently Used)  
  - 메모리 내 참조된 횟수가 가장 적은 페이지를 선택하여 교체
  - 막대한 오버헤드
- 2차 기회 페이지 교체  
  - 참조 비트가 0이면서 메모리 내에 가장 오래 있었던 페이지를 선택하여 교체  
  
- 프로세스가 페이지 프레임 개수 관리하는 2가지 방법 
  - 워킹 세트 알고리즘
    - W(t, δ): t ~ (t - δ + 1) 시간동안 참조한 페이지의 집합 
  - PFF 알고리즘(Page Fault Frequency)
    - 페이지 부재 빈도를 이용하여 프로세스별 페이지 집합의 크기를 변화시키는 기법
    - 프로세스별 페이지 집합이 워킹 세트 알고리즘처럼 자주 바뀌지 않음

<br/>
<hr>

## 장치관리

- 입출력장치 
  - 전용장치
    단 하나의 프로세스만 할당(프린터, 테이프 드라이브 등..)
  - 공용장치
    여러 프로세스에 동시 할당
  - 가상장치
    공용장치처럼 보이는 전용장치  

### 장치의 구성

- 장치제어기
  - 하드웨어 내 장치를 직접 다루는 전자장치 
  - 하드웨어 내 존재 
  - 운영체제가 보내는 출력을 장치에 맞게 변환
  - 장치에서 발생하는 각종 데이터를 전자신호로 변환하여 운영체제로 전달  
  
- 장치 드라이버 
  - 운영체재 내 존재하여 응용 프로그램의 입출력 요청을 해당 장치에 맞도록 변환
  - 장치의 종류나 제조사에 따라 장치제어기가 이해하는 명령이나 명령의 종류가 다를 수 있기 때문
  - 보통 장치 제조사에서 해당 장치의 드라이버도 같이 제공
  - 장치 드라이버는 하드웨어가 아닌 운영체제에 속하는 소프트웨어의 개념  

<br/>

`버스`: 컴퓨터 안의 부품들 간에, 또는 컴퓨터 간에 데이터와 정보를 전송하는 통로  

<br/>

- CPU의 장치 사용법  
  1. 버스를 통해 각 장치제어기의 레지스터를 이용
  2. 메모리에 접근하여 각 장치제어기의 매핑된 정보를 활용하여 간접적으로 제어  
  
- 입출력 처리 유형
  - 프로그램 방법
    - CPU만 이용하는 폴링을 이용하여 입출력을 처리  
    - Polling: CPU만 혼자 일을 함
    - CPU 낭비 심해 비효율적
  - 인터럽트 방법
    - CPU는 인터럽트를 받기 전까지 다른 작업을 하다 인터럽트를 받으면 처리해주고 다시 다른작업을 한다.  
  - DMA 방법(Direct Memory Access)  
    - DMA 제어기를 이용하여 CPU를 사용하지 않고 메모리에 직접 접근하여 데이터를 전송하는 방법  
  
- 사이클 스틸링(Cycle Stealing)
  CPU와 DMA제어기 둘 다 메모리를 사용하여 동시에 메모리에 접근할 경우 DMA 제어기에 우선권을 준다.   
  
- 입출력장치와는 독립적인 입출력 관리방법 2가지 
  - 버퍼링
    - 버퍼를 이용하여 CPU의 데이터 처리 속도와 I/O장치의 데이터 전송속도의 차이로 인한 문제를 해결  
    - 버퍼를 두어 데이터 전송속도를 높인다.  
    - 단일 버퍼링
    - 이중 버퍼링
    - 순환 버퍼링
  - 스풀링  
    - 입출력 프로세스와 저속 입출력장치 사이의 데이터 전송을 자기 디스크와 같은 고속장치를 통하도록 하는 것  
    - 자기디스크에 출력과 관련된 데이터들을 만들어 놓으며 I/O 장치가 여유있을 때 데이터를 보내여 출력한다.
    - 프로세스 입장에서는 입출력 작업이 빨리 끝남  

<br/>
<hr>

## 저장장치 및 파일관리  

### 저장장치의 종류

- 순차접근 저장장치
  - 데이터를 순차적으로 읽거나 쓸 수 있는 저장장치
  - 예: 테이프 장치
  - 초기 접근시간이 굉장히 오래 걸림
  - 대량의 데이터 백업용으로 사용
- 직접접근 저장장치 
  - 지정한 위치를 직접 찾아 데이터를 읽거나 쓸 수 있는 저장장치
  - 예: 자기 디스크, 광디스크, SSD
  
- 자기 디스크  
  자성을 띤 디스크의 표면에 데이터를 쓰거나 읽는다.   
- 광디스크  
  디스크 표면에 레이저를 쏘아 반사되는 빛의 차이를 이용하여 데이터를 읽거나 씀  
  예: CD-ROM, CD-RW, DVD, 블루레이 디스크 등  
  나선형인 하나의 트랙으로 구성 ( 모기향 모양 )  
  사용성이 점점 줄고있다.  
- SSD  
  읽고 쓰기가 가능하면서 전력공급이 없어도 데이터가 지워지지 않는 메모리 이용  
  자기 디스크보다 속도가 엄청 빠르고 전력 소모가 적음  
  용량 대비 가격이 비싸며 수명이 짧음  
  
- 디스크 스케줄링: 디스크 내 여러 프로세스 중 실행 순서를 결정한다.  
  
탐구시간( Seek Time ): 헤드가 트랙으로 움직이는 시간  
회전지연시간( Rotational Delay Time ): 트랙 내 원하는 섹터에 도달하기 까지의 걸리는 시간  
전송시간: 섹터 내 원하는 데이터를 찾는 시간  
  
- 스케줄링의 형태
  - 탐구시간 최적화
    - FCFS 스케줄링: 디스크 큐에 먼저 접근한 요구 서비스가 실행
    - SSTF 스케줄링: 탐구시간이 가장 짧은 접근 요구 먼저 처리(근처에 있는 것부터 실행) 
    - SCAN 스케줄링: 양 끝 트랙 왕복하여 처리(엘리베이터)
    - C-SCAN 스케줄링
    - LOOK 스케줄링: SCAN 스케줄링으로 처리하되 진행방향에 더 이상 접근 요구가 없으면 방향을 바꾼다.  
    - C-LOOK 스케줄링
  - 회전지연시간 최적화
    - SLTF 스케줄링(Shortest Latency Time First): 동일 실린더의 여러 섹터에 대한 접근 요구에 대해 회전지연시간이 가장 짧은 것을 먼저 처리하는 방법  
  
- 파일 구조: 파일을 구성하는 레코드들이 보조기억장치에 배치되는 방식  
- 파일 구조 접근 방식 
  - 순차 파일
    - 레코드가 물리적 순서에 따라 저장되어 있는 파일
    - 논리적 순서와 물리적 순서가 동일
  - 인덱스된 순차 파일
    - 각 레코드의 키를 기준으로 한 논리적 순서대로 레코드가 저장됨
    - 일부 주요 레코드의 실제 주소가 저장된 인덱스를 구성하여 관리하는 파일
    - 순차접근( 키 순서 )과 직접접근 ( 인덱스 검색 ) 모두 가능
    - 보통 디스크에 이용
  - 직접 파일
    - 각 레코드의 키를 이용하여 직접접근 저장장치의 물리적 주소를 통해 직접 액세스되는 파일
    - 논리적인 키와 물리적 주소의 사상은 프로그래머가 정의
  
- 디스크 공간 할당
  - 연속 할당 기법
    - 보조기억장치의 연속된 가용공간에 파일 저장공간을 할당
    - 필요한 공간의 크기를 미리 정해야 함
    - 액세스가 효율적
    - 디렉토리 구현이 단순
  - 불연속 할당 기법
    - 섹터 또는 블록 단위로 공간을 할당  
    - 포인터를 이용하여 블록들을 연결  
    - 단편화 문제 해결 
    - 파일 확장 문제 해결 
    - 파일 공간 분산으로 성능 저하  
    - 포인터 관리를 위한 연산 및 공간 소비  

<br/>
<hr>

## 분산 운영체제

**분산 시스템**: 크기나 성능이 다를 수 있는 여러 대의 컴퓨터가 네트워크로 연결되어 이루어지는 시스템  
  
- 분산 시스템 장점
  - 자원공유
    - 각 컴퓨터의 자원을 네트워크로 연결된 컴퓨터가 공유
    - 예: 프린터 공유, 1,000대 컴퓨터의 각 256GB 저장장치 등
  - 성능 향상
    - 여러 대의 프로세서에 작업을 분할하여 병렬적으로 동시 수행
    - 많은 클라이언트가 동시에 작업을 요청할 때 복수의 서버가 처리
  - 신뢰성 향상
    - 한 대가 고장나더라도 다른 컴퓨터가 작업을 계속 수행
    - 하드웨어나 데이터의 중복을 통한 해결 가능
  - 통신의 편리성
    - 단일 시스템 내부에서 동작하는 서비스와 같은 서비스 제공 ( 예: A 위치의 파일을 B 위치로 복사 )  
  
- 네트워크 연결방법 2가지
  - 완전연결 네트워크
  - 부분연결 네트워크
    - 트리구조
    - 스타형
    - 링형
    - 버스형  
  
- 망 구축비용: 사이트들을 물리적으로 연결하는 비용 ( 완전연결 비용↑, 부분연결 비용↓ )
- 통신비용: 메시지를 보내는데 필요한 비용 ( 완전연결 비용↓, 부분연결 비용↑ )
- 신뢰성: 링크나 사이트 고장 시 정상적 동작 가능 정도 ( 완전연결 비용↑, 부분연결 비용↓ )  
  
- 네트워크 연결방법
  - LAN(local Area Network)
  - WAN(Wide Area Network)
  
### 분산 웅영체제

**분산 시스템을 관리하기 위한 운영체제**  
  
- 투명성 제공 
  - 로컬 자원과 원격 자원의 구분을 없애 줌
  - 원격 자원 접근에 필요한 일들을 분산 운영체제가 대신 해 줌
- 분산 운영체제에 적용할 수 있는 방법
  - 데이터 이주
  - 계산 이주
  - 프로세스 이주
  
- 데이터 이주
  - 원격 데이터를 로컬로 전송해 와서 사용하는 방식
- 계산 이주
  - 계산을 원격지에서 처리하고 결과를 전송받는 방식
  - 원격 프로시저 호출(RPC) 이용
- 프로세스 이주
  - 프로세스 자체를 원격지로 이주시키는 방식
  - 작업량 분산, 목적에 부합한 곳에서 프로세스 실행시켜 성능 향상  

### 분산 파일 시스템

- 클라이언트가 원격 파일을 로컬 파일처럼 사용할 수 있게 해준다
- DFS 네이밍 방식(Depth First Search)
  - 호스트 이름과 로컬 이름을 조합
  - 원격 디렉토리를 로컬 디렉토리에 마운트
  
- 원격 파일에 대한 요청 처리
  - RPC 통해 구현(Remote Procedure Call)
  - 네트워크 사용이 많아지면 효율성에 문제  
  
- 캐시를 이용한 분산 파일 시스템
  - 전체 시스템의 성능 높임
  - 고려할 문제
    - 캐시 교체 정책
    - 캐시 일관성 문제 등..  

### 분산 메모리

원격 시스템의 메모리를 효율적으로 접근할 수 있게 한다.  
- 원격 메모리: 원격 메모리 API 이용
- 분산 공유 메모리  
  - 물리적으로 분리된 메모리를 하나의 주소공간을 통해 접근할 수 있게 해 줌
  - 운영체제가 내부적으로 어떤 것을 사용할지 결정한다.   
  
- NUMA(Non-Uniform Memory Access)  
  - 각 프로세서가 로컬 메모리를 갖는 분산 공유 메모리
  - 저장 위치에 따라 속도 차이 발생  

### RPC(Remote Procedure Call)

- 원격 프로시저 호출 동작
  - 클라이언트는 같은 주소공간에 있는 스텁 루틴 호출
  - 스텁 루틴은 매개변수나 결과를 메시지로 만든 후 네트워크를 통해 전달한다.  
  
- 고려사항
  - 이상적으로 RPC사용과 로컬 프로시저 사용이 구별되지 않아야 한다. 
  - 서로 다른 주소공간에 속하기 때문에 메모리 주소를 리턴하는 참조 호출은 의미 없다. 
  - PRC 수신자는 호출이 생성된 곳과 유사한 환경에서 실행해야 한다. 

<br/>
<hr>

## 운영체제 보안

기밀성: 원치않는 주체에게 자원이 나가도록 막아주는 것  
가용성: 자원을 쓸 수 있는 주체가 해당 자원을 항상 사용할 수 있다.   
무결성: 객체/자원에 저장된 정보는 항상 정확함  
  
- 정보침해  
  운영체제 보안의 기본 목표가 달성되지 못하고 정보가 불법적으로 읽히거나(기밀성 훼손) 다른 값이 덮어 쓰이는 것(무결성 훼손)  
  
- 정보침해 형태
  - 가로채기
    - 공격자가 허락받지 않은 컴퓨터 자원에 접근하여 가로챈다. (기밀성 공격)
  - 흐름 차단
    - 시스템의 일부를 파괴하거나 사용할 수 없게 함 (가용성 공격)
  - 변조
    - 공격자가 기존에 있던 데이터의 내용을 바꿈(무결성 공격)
  - 위조
    - 공격자가 기존에 없던 불법적인 정보를 삽입(무결성 공격)  
  
- 정보침해 유형
  - 트로이목마: 숨겨진 기능이 있는 프로그램을 사용자가 실행하게 만들어 사용자의 권한을 이용하여 시스템에 침투
  - 트랩도어: 정상적인 인증절차나 암호화를 피해 갈 수 있는 비밀통로
  - 비밀채널: 데이터를 주고받을 수 없는 프로세스 사이에 정상적이지 않은 방법으로 정보를 주고받음
  - 웜: 자기 자신을 복사하여 다른 컴퓨터에 전파
  - 바이러스: 다른 프로그램을 감염시켜 전파  

### 운영체제 보안 모델

참조 모니터 모델: 주체가 객체 사이에 위치하여 주체가 객체에 접근하는 과정에 대해 접근제어 수행
  
정보 흐름 모델: 정보의 유형에 따라 정보가 흐르는 방향을 제어하는 모델  
- 벨-라파듈라 모델(BLP)
  - 상위 보안 수준에서 하위 보안 수준으로 정보가 흐르는 것을 방지하는 것이 주된 목적
  - 기밀성 유지
  - 무결성 깨질 가능성 
- 비바 모델(Biba)
  - 하위 보안 수준에서 상위 보안 수준으로 정보가 흐르는 것을 방지하는 것이 주된 목적  
  - 무결성 보장

<br/>
<hr>

## 운영체제 사례

### Linux

- 리눅스의 개요
  - 1991년 Linus Torvalds가 MINIX에 기반하여 개발
  - MINIX: 마이크로 커널 구조의 아주 작은 수업용 운영체제
  - 오픈 소스
  - 개발자 뿐 아니라 일반인 및 기업용으로 사용 가능한 운영체제
  - 인텔 CPU뿐 아니라 ARM 등 다양한 CPU를 지원
  - 실습용 컴퓨터부터 슈퍼컴퓨터까지 널리 사용됨
- 리눅스의 장점
  - 무료 사용 가능
  - UNIX와 완벽하게 호환 가능
  - 높은 안정성
  - 낮은 성능의 하드웨어에서 동작 가능
  - 개인용 컴퓨터에서 서버 기능 수행 가능
- 리눅스의 단점
  - 무교육, 유지보수 문제
  - 보안 문제가 상대적으로 심각할 수 있음
  - 떨어지는 보급률
  - 특정 하드웨어가 지원되지 않을 수 있음(최근에는 좋아지고 있음)
  
- 리눅스 커널
  - 일체형 커널
    - 오픈 소스여서 필요 없는 부분은 제거 가능
  - 멀티태스킹, 멀티유저 시스템
  - 멀티코어, 멀티프로세서 지원
  - 여러 가지 하드웨어 지원
    - 리눅스의 대부분은 C언어로 작성되어 있어 다양한 플랫폼에 손쉽게 이식된다.
  - UNIX 표준인 POSIX 표준 지원
  - 프로세스 간 통신 지원
    - 세마포어, 메시지 큐, 공유 메모리 등
  - 다양한 파일 시스템 지원
    - ext4, FAT, NTFS, HPFS
  - 모듈
    - 필요한 서비스를 모듈로 만들어 커널을 교체하거나 시스템을 재시동하지 않고 기능   - 추가 가능하다. 
  - 파일 형태의 주변장치 접근

<br/>

- ```임베디드 시스템```
  - 미리 정해진 특정한 기능을 수행하기 위해 하드웨어와 소프트웨어를 결합하여 설계된 컴퓨터 시스템
  - 한 가지 일을 잘하도록 설계된 시스템
    - 예: 세탁기
    - 여러 센서를 이용하여 물의 양, 세탁물에 대한 정보 등 측정
    - 효율적인 세탁을 위해 임베디드 시스템의 제어를 통해 동작
  - 보통 실시간 시스템에 이용됨

- 실시간 시스템
  - 시스템의 상황과 무관하게 정해진 마감시간 내에 주어진 이벤트에 반응해야 함
  - 실시간 운영체제(RTOS: Real Time OS)는 빠르게 주어지는 마감시간 내에 작업을 처리하는데 중점을 둠
  
- 경성 실시간 시스템
  - 반드시 마감시간 내 작업을 완수해야 한다.  
  - 예: 항공기 전자제어 시스템, 심박동기 등
- 연성 실시간 시스템
  - 마감시간 내 작업을 완수하면 좋지만 못해도 실패는 아니다.    
  - 예: 멀티미디어 재생  
  
- 임베디드 리눅스
  - 임베디드 시스템을 위해 개발된 리눅스
  - 필요 요건
    - 소용량 메모리를 감안하여 운영체제의 크기를 최소화하여 필요한 부분만 남겨야 함
    - 저성능 CPU를 감안하여 성능이 최적화되어야 함
    - 리눅스는 원래 범용 컴퓨터 시스템을 위한 운영체제이므로 실시간 시스템 요구사항에 대응할 수 있어야 한다. 
  - 임베디드 리눅스 장점
    - 무료로 사용 가능하며, 운영체제를 응용에 적합하게 수정 가능
    - 많은 사용자와 개발자로부터 검증받았으며, 많은 검증된 코드를 바로 사용 가능
    - 운영체제의 최신 동향 반영
    - 리눅스에 익숙한 개발자는 빠르게 적응 가능
  - 임베디드 리눅스 단점
    - 경성 실시간 시스템에 적절하지 못하고 요구되는 H/W 사양 높음  
  