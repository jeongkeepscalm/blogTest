---
title: "[U-KNOU] 데이터베이스 시스템"
description: "[U-KNOU] 데이터베이스 시스템"
date: 2024-05-28
categories: [ U-KNOU, Database System ]
tags: [ U-KNOU, Database System ]
---

# 1강. 데이터베이스의 이해 

- 데이터의 단위  
  - bit < byte < KB(kilobyte) < MB(megabyte) < GB(gigabyte) < TB(terabyte) < PB(petabyte) < EB(exabyte) < ZB(zettabyte) < YB(yottabyte)  

### 파일처리 시스템  

- 파일처리 시스템  
  - 데이터베이스 개발 전 데이터 관리에 사용  
  - 업무 별 애플리케이션이 개별 데이터를 데이터 파일에 저장/관리하는 시스템  
  
- 파일처리 시스템 문제점  
  - 데이터 종속의 문제
  - 데이터 중복의 문제
    - 일관성: 특정 데이터 수정 시 중복되는 모든 데이터를 수정해야 한다. 
    - 보안성: 같은 데이터에 같은 수준의 보안 유지 필요
    - 경제성
  - 무결성 훼손의 문제
    - 데이터의 정확성을 보장하지 않는다. 
    - 데이터의 값과 값에 대한 제약조건을 동시에 만족하지 못한다.  
  - 동시 접근의 문제

### 데이터베이스 특징

  - 자기 기술성(자신이 어떤 데이터를 다루고 있는지 인지)
  - 프로그램과 데이터의 격리 및 추상화
  - 다중 뷰 제공: 사용자가 관심을 갖는 데이터베이스의 일부만 표현할 수 있다.  
  - 데이터 공유와 다수 사용자 트랜잭션 처리
    - 다수의 데이터 조작 요청을 동시성 제어 기능을 통해 데이터 일관성 보장 및 동시 작업 수행 가능
    - 한 트랜잭션이 끝날 때까지 다른 트랜잭션은 해당 데이터에 대한 접근을 막는다.  
    - `트랜잭션`: 하나의 논리적 작업을 처리하기 위한 일련의 데이터베이스 명령의 집합  
  
- 데이터: 하나의 값에 2개 이상의 설명이 있는 것  
- 메타데이터: 값에 대한 부연설명  
- 데이터베이스: 애플리케이션 시스템에서 사용되는 데이터의 집합
- DBMS(Database Management System): 데이터베이스에 저장된 데이터의 구성, 저장, 관리, 사용을 위한 소프트웨어 패키지
- 데이터베이스 시스템: 정보를 데이터베이스에 저장, 관리하여 사용자에게 요구된 형태의 정보로 제공하는 컴퓨터 기반 시스템

### DBMS 3단계 구조

<img src="/assets/img/knou_database_system/schema.png" width="600px">  
  
- `내부단계`   
  - 데이터가 어디에 어떻게 저장되어 있는지와 같이 `데이터의 물리적인 저장 방식`을 관리      
- `개념단계`    
  - 전체 데이터베이스의 구조와 데이터 간의 관계를 정의   
  - 메타데이터를 사용하여 데이터의 규모, 구조, 의미 등을 명시   
- `외부단계`   
  - 사용자 또는 응용 프로그램이 데이터에 접근하는 방식을 정의  
  - 자신의 목적에 맞는 필요한 데이터를 볼 수 있다.  
  - 사용자의 요구에 따라 다양한 뷰를 제공하여 데이터를 보다 쉽게 이해하고 사용할 수 있게 한다.   
- `외부-개념사상`   
  - 논리적 데이터 독립성이 확보되는 과정   
- `개념-내부사상`   
  - 데이터베이스의 논리적 구조와 물리적 저장 방식 사이의 매핑을 관리  
  - 애플리케이션이 데이터베이스의 물리적 구조에 영향을 받지 않도록 한다.   
  
- `DBMS 3단계 구조의 특징`  
  - 데이터의 물리적인 저장 방식과 사용자의 데이터 접근 방식 사이의 독립성을 보장   
  - 사용자는 데이터의 물리적인 저장 방식을 몰라도 데이터에 접근하고 사용  
  - 데이터의 물리적인 저장 방식이 변경되더라도 사용자의 데이터 접근 방식에는 영향을 미치지 않음  

### 데이터베이스 언어

- 데이터 정의 언어(DDL: Data Definition Language)   
  - 데이터베이스 객체를 생성, 수정, 삭제하기 위한 언어  
  - 데이터의 논리적 구성이나 특징을 규정  
  - 데이터가 기억장치에 저장되도록 데이터의 물리적 구성을 규정  
  - 데이터의 물리적 구성과 논리적 구성간의 사상을 규정  
  
- 데이터 조작 언어(DML: Data Manipulation Language)  
	- 구조화된 데이터에 사용자가 접근 및 조작할 수 있도록 지원하는 언어  
	- 사용자의 요청을 시스템 내부에서 효율적으로 처리 가능  

### 데이터베이스 시스템 아키텍처

- 중앙집중식 방식
  - 단일 서버가 다수의 클라이언트 장치를 대신하여 작동
  - 중앙 컴퓨터의 과부하로 전체적인 성능 저하
- 분산 시스템 방식
  - 클라이언트-서버 데이터베이스 시스템
  - 애플리케이션 프로그램의 부하를 분산
  - 소프트웨어의 유지보수 비용을 절감 및 이식성 증가

<br/>
<hr>

# 2강. 데이터베이스 모델링

### 데이터베이스 모델링 이해

- 비지니스 관점: 어떤 데이터를 저장해야 하는가?  
- 컴퓨터 프로그래머 관점: 어떻게 데이터를 저장해야 하는가?  
  
<img src="/assets/img/knou_database_system/modeling.png" width="600px">   
  
- 데이터 모델: 의미, 데이터 타입, 연산 등을 명시하기 위해 사용할 수 있는 개념들의 집합  
- 데이터 모델링: 실세계의 일부분을 DBMS가 지원하는 데이터 모델의 형태로 나타내는 과정  
  1. 개념적 데이터 모델링(어떤 데이터를 저장할 것인가?)  
    - 사용자의 요구사항의 분석  
    - 실세계의 데이터를 개념적으로 일반화하여 데이터 구조, 데이터 타입, 속성, 관계, 제약조건 등을 이끌어내는 과정  
  2. 논리적 데이터 모델링(저장할 데이터를 DBMS에 어떻게 저장할 것인가?)  
    - 개념적 데이터 모델링을 통해 만들어진 결과물을 특정 DBMS에 저장할 수 있는 모델로 변환시키는 작업  
  3. 물리적 데이터 모델링  
    - 데이터베이스 파일의 내부 저장구조, 파일 구성, 인덱스, 접근 경로 등을 결정하는 과정  
▶ 1 ~ 3 과정을 거쳐 내부 스키마가 만들어진다.  

### 사용자 요구사항 분석

- 제안요청서(RFP: Request For Proposal) → **요구사항 도출** → 요구사항 명세서 → **요구사항 분석** → 요구사항 정의서 → **요구사항 기록**  
  
- 요구사항 도출  
  - 구축대상, 프로젝트 목표, 범위를 기준으로 조사범위를 결정  
  - 업무관계자 인터뷰  
  - 외부자료 수집 및 분석  
- 요구사항 분석  
  - 도출된 요구사항의 명확성, 완전성, 모호성 검증  
  - 불완전한 부분이 존재할 경우 요구사항 도출단계 재수행  
  - 요구사항을 분류하여 통합 또는 분리  
- 요구사항 기록  
  - 요구사항 목록 정리 및 관리자의 승인  
  - 정리된 요구사항을 형식에 맞춰 문서화  
  - 프로젝트 종료 때까지 반영 여부 지속적 관리  

### ER 모델

- ER 모델의 개념  
  - P.Chen 박사 제안  
  - 실세계 속성으로 이루어진 `개체(Entity)`와 개체 사이의 `관계(Relationship)`를 정형화시킨 모델  
  - `개념적 모델링 단계`에서 사용되는 데이터 모델  
  - 데이터 구조와 관계를 ER다이어그램(ERD)으로 표현  
  - 구성요소: 개체집합, 관계집합, 속성  
  
- 개체(Entity)   
  - 실세계에 존재하는 다른 객체와 구별되는 유무형의 사물  
  - 개체를 설명하는 여러 속성으로 구성  
- 개체집합(Entity Set): 같은 속성을 공유하는 개체들의 모임  
  
- 관계: 개체와 개체 사이의 연관성  
- 관계집합: 개체 집합 간의 연결 관계  
  
- 속성(컬럼)
  - 개체를 구체적으로 설명
  - 속성의 종류  
    - 단순 속성: 더 작은 구성요소로 나눌 수 없는 속성(이름, 성별, 나이)  
    - 복합 속성  
      - 더 작은 요소로 나눌 수 있는 속성(생년월일, 년/월/일)  
      - 들여쓰기로 구분  
        생년월일  
          년  
          월  
          일  
    - 단일값 속성: 한 개체에 대해 단 하나의 값만을 갖는 속성(주민번호 등..)  
    - 다중값 속성  
      - 한 개체에 대해 여러 개의 값을 갖는 속성  
      - 예: {전화번호}  
    - 유도 속성  
      - 다른 속성의 값으로부터 값이 유추될 수 있는 속성   
      - 예: 나이(생년월일로 유추가 가능)  
    - 저장 속성: 유도 속성을 위해 사용될 수 있는 속성  
  
- 정리
  - 개체(entity): 데이터의 한 행  
  - 개체집합(entity set): 테이블  
  - 속성: 컬럼  
  - 생년월일의 속성: 복합 속성 && 단일값 속성 && 유도 속성  
  
- <img src="/assets/img/knou_database_system/0.jpg" width="600px">  

### 제약조건

- ER모델은 개체와 관계에 대한 표현의 정확성을 위해 데이터가 준수해야하는 제약조건을 정의할 수 있는 표현 방법을 제공한다.  
  
- 제약조건의 종류  
  1. 사상수(Mapping Cardinality): 관계집합에 참가한 개체집합에 대해 한 개체가 다른 개체와 관계를 맺을 수 있는 수량을 명시  
    - <img src="/assets/img/knou_database_system/1.jpg" width="600px">
    - 일대일(1:1)
    - 일대다(1:N)
    - 다대일(N:1)
    - 다대다(N:N)
    width="600px">  
  2. 참가 제약 조건(Participation Constraints)  
    - <img src="/assets/img/knou_database_system/2.jpg" width="600px">  
    - 전체적 참가: 어떤 개체집합의 모든 개체가 관계집합에 참여하는 조건(과목개체집합)
    - 부분적 참가: 어떤 개체집합의 일부 개체가 관계집합에 참여하는 조건(교수개체집합)  
  3. 키 속성  
    - 각 개체를 구별하는데 사용되는 유일한 값을 가지는 속성의 집합
    - 개체를 고유하게 구분하는 역할
    - 관계 집합의 특정 관계를 찾는 사람
  4. 특수 속성과 특수 관계  
    - <img src="/assets/img/knou_database_system/mapping2.jpg" width="400px">
    - `관계집합의 속성`: 두 개체집합의 관계에서 생성되는 값을 저장하는 속성(신청시각)
    - 재귀적 관계: 한 개체집합이 자기 자신과 집합을 형성하는 관계(선수과목)  
    
    - <img src="/assets/img/knou_database_system/3.jpg" width="600px">  
    - <u>학생 개체집합과 계좌 개체집합이 보유 관계집합으로 연결되어 있을 경우</u>
      - `약한 개체집합`(== 계좌 개체집합)
        - 개체의 존재 유무가 관계를 맺고 있는 개체의 존재에 종속되는 개체집합
      - `강한 개체집합`(== 학생 개체집합)
        - 약한 개체집합과 연결되는 일반 개체집합
        - 계좌 개체가 삭제되어도 학생 개체는 삭제될 필요없다. 

<br/>
<hr>

# 3강. 관계형 모델

### 관계형 모델의 개념

- 논리적 데이터 모델링 단계
  1. DBMS에서 사용하는 데이터 모델에 맞추어 데이터를 표현하는 과정
  2. 데이터 정의 언어(DDL)로 기술된 개념 스키마 생성
  3. 관계형 모델(Relational Model)
    - 에드가 F.코드(1969년)
    - 릴레이션으로 데이터를 표현하는 모델
    - 데이터 표현이 단순하고 직관적 구조화 모델
    - 현재 대다수 DBMS의 기초

### 릴레이션

- 릴레이션의 구성
  - `릴레이션`: 표 형태의 구성
  - 스키마: 모든 컬럼
  - 컬럼: 속성, 필드
  - 행: 레코드, 투플
  - 여러 행: 인스턴스
  
- 릴레이션의 특징
  - 레코드의 유일성: 중복된 레코드 존재 불가
  - 레코드의 무순서성: 레코드의 순수는 의미 없음
  - 컬럼의 무순서성: 컬럼은 순서가 없고 이름과 값의 쌍
  - 컬럼 값의 원자성: 모든 컬럼값들은 나눌 수 없는 단 하나의 의미  
    예: 컬럼값이 {사과, 바나나, 수박} 이런 형식으로 들어가지 않는다.  
  
- 키의 종류
  - 슈퍼키(Super Key): 유일성(Unique) 만족
  - 후보키(Candidate Key): 유일성 & 최소성 만족
  - 기본키(PK: Primary Key): 레코드 구분을 위해 선택된 후보키
  - 외래키(FK: Foreign Key): 참조된 다른 릴레이션의 기본키
  
- 관계형 모델의 제약조건
  - 영역 제약조건: 컬럼에 정의된 영역(Domain)에 속한 값으로만 컬럼값이 결정
  - 키 제약조건: 키는 레코드를 고유하게 구별하는 값으로 구성
  - 개체 무결성 제약조건: 기본키의 값 null 불가
  - 참조 무결성 제약조건: 다른 레코드의 기본키만 참조가능
  
- <img src="/assets/img/knou_database_system/4.jpg" width="600px">  
  - 일대다
  - 과목 개체집합은 모든 개체가 관계집합에 참여하는 전체적 참가(===== 두 줄로 표현)
  - 전체적 참가하는 과목 개체집합에 FK 생성(교수번호)
  - <img src="/assets/img/knou_database_system/6.jpg" width="600px"> 
  - 다대다
  - `다대다 관계에서는 새로운 릴레이션 생성 필요`
  - 새 릴레이션 구성 {학생번호(PK, FK), 과목번호(PK, FK), 신청시각}
  
- <img src="/assets/img/knou_database_system/3.jpg" width="600px"> 
  - 일대일
  - 보유 관계집합: 약한 관계집합(2중선)
  - 계좌 개체집합: 약한 개체집합
  - `일대일 관계`에서는 양쪽 다 외래키 존재가능하지만 보통 `컬럼 수가 적은 곳에 외래키 위치`
  - `약한 개체집합에서 참조된 외래키`는 기본키로 추가되어 `복합키`를 이룬다. 
    - 학생 릴레이션{학생번호(PK), 학생이름, 성별 ...}
    - 계좌 릴레이션{계좌번호(PK), 잔액, 학생번호(PK, FK)}
    - 복합키로 설정을 하면 학생이 전학을 갔을 때, 학생 릴레이션에서 삭제되고 계좌 릴레이션에서 학생번호는 PK이기 때문에 무조건 같이 삭제되어야 한다.

### 데이터 연산

- 관계연산의 개념
  - 관계형 모델을 기반으로 구성된 릴레이션을 사용하여 새로운 릴레이션을 생성하는 표현
  - 사용자의 관점에서 필요한 데이터를 릴레이션에서 추출하는 방법을 제공하는 도구
  - `관계 대수(relational algebra)`
    - 관계 연산을 정의하는 방법
    - 주어진 릴레이션에서 필요한 릴레이션을 만드는 연산자로 구성
      (σ, π, ×, -, ∪, ∩, ⋈ ..)
    - 관계 대수 연산자는 새로운 임시 릴레이션을 생성
    - 연산자를 중첩하여 연산 처리 절차를 표현
  
- `σ(Selection) 셀렉트 연산`: 레코드(행) 단위로 데이터를 가져온다.
  - <u>σ소속학과 = ‘컴퓨터과학과’ (교수)</u>  
    교수테이블 내 소속학과가 컴퓨터학과인 데이터 조회  
  - σ소속학과 = ‘컴퓨터과학과’∧연봉>=50000000 (교수)  
	  교수테이블 내 소속학과가 컴퓨터학과이고 연봉이 5천만원 이상인 데이터 조회
	  - ∧ == and 
	  - ∨ == or
- `π(Projection) 프로젝트 연산`: 기술된 컬럼만 가져온다.
  - π교수이름, 소속학과 (교수)  
	  교수테이블 내 컬럼명이 교수이름과 소속학과인 데이터를 가져온다.  
  - π 교수이름 ( σ직위 = ‘부교수’ (교수) )  
    직위가 ‘부교수’인 교수의 교수이름을 출력  

### 집합 연산자

- A∪B 합집합 / A∩B 교집합 / A-B 차집합
- 릴레이션은 집합, 레코드(행)는 집합에 포함된 원소
- 집합 연산자 사용 조건
  - 두 릴레이션의 차수(컬럼의 수)가 동일해야한다. 
  - 두 컬럼의 도메인(영역: 데이터타입)이 일치해야한다.
  
- 카티시언 프로덕트 연산: 두 릴레이션을 하나의 릴레이션으로 결합
- <img src="/assets/img/knou_database_system/5.jpg" width="600px"> 
  
- 조인 연산: 조건에 만족하는 레코드들만 결합
- <img src="/assets/img/knou_database_system/7.jpg" width="600px"> 
  
- Quiz 1. ‘컴퓨터과학과’ 소속의 교수가 강의하는 과목의 과목명과 과목코드는?
  - 카티시언 프로덕트 사용
    - π 과목명, 과목코드 ( σ 교수.소속 = ‘컴퓨터과학과’ ( σ 과목.교수번호 = 교수.교수번호 ( 과목 x 교수 ) ) )
  - 조인연산 사용
    - π 과목명, 과목코드 (  σ 교수.소속 = ‘컴퓨터과학과’ ( 과목 ⋈ 과목.교수번호 = 교수.교수번호 교수 ) )
  
- 집계 함수 연산
  - Quiz 2. 과목명의 개수는?
    - F count(과목명) (과목)
  - Quiz 3. 각 학과에 소속된 교수는 몇명일까?
	  - 소속학과 G 소속학과, count(*) (교수)
	  - == select 소속학과, count(*) from 교수 group by 소속학과;

<br/>
<hr>

# 4강~6강. SQL

### SQL의 개요

- Structured Query Language 은 관계대수에 기초하여  RDBMS  의 데이터 관리를 위해 설계된 언어.
- 1986년 ANSI
- 1987년 ISO 표준으로 제정
- 비절차적 언어: 필요한 것만 간단하게 가져올 수 있다. 
- 인간의 언어와 매우 유사하고 간단, 명료하다. 

### 데이터배이스 언어

- `데이터베이스 정의 언어(DDL: Data Definition Language)`	
  - 데이터베이스 내 `객체를 생성 및 삭제`하고 그 `구조를 조작`하는 명령어의 집합
    - 데이터베이스 객체의 종류
      - 데이터 저장: `테이블`, `인덱스`, `뷰`
      - 데이터 조작: `트리거`, `프로시저`, `함수` 등
    - 스키마의 정의
      - 스키마 == 데이터베이스
      - 한 조직의 데이터베이스 시스템의 운영에 필요한 테이블, 인덱스, 뷰 등 데이터베이스 객체의 집합
      - 스키마 관리 방법
      - Forward Engineer
      - SQL 에디터
      - 내비게이터 패널
  - 데이터가 준수해야 하는 `제약조건`을 기술
  - 스키마/데이터베이스 생성/삭제
    - CREATE schema 스키마명
    - DROP schema 스키마명
  - e.g. CREATE, ALTER, DROP
  
- `데이터베이스 조작 언어(DML: Data Manipulation Language)`
  - DDL에 의해 정의된 테이블에 데이터를 조작하는 명령어의 집합
  - e.g. CRUD

### 데이터 타입

- 컬럼이 가질 수 있는 값의 범위, 즉 `도메인`을 결정

- char vs varchar
  - char: 데이터 메모리가 정해져 있다. 
  - varchar: 데이터 메모리가 변한다. 
  
- text, clob: 길이가 최대  2~4gb인 가변길이 문자열
- enum: 유한개의 문자열 집합 중 하나의 값을 선택
  - 성별: enum(‘남’, ‘여’)
  - 혈액형: enum(‘A’, ‘B’, ‘C’, ‘D’)

### 제약조건

- **테이블과 테이블에 존재하는 데이터를 보다 무결하게 관리하기 위한 목적으로 사용**
- DBMS는 테이블 조작 시 테이블에 정의된 제약조건을 만족시키는지 지속적으로 검사
- DBMS는 적용하려는 제약의 유형에 따라 다양한 제약조건을 지원
  
- PK(Primary Key): unique + not null
- FK(Foreign Key): 다른 테이블의 기본키(참조 무결성 보장)
- NOT NULL
- UNIQUE: 중복된 값 허락 X
- AUTO_INCREMENT
- CHECK: 열에 입력되는 값을 검사하여 특정 조건 준수 여부 확인

### 중첩 질의 

- subquery

### 조인 질의

- ER모델링 및 정규화 기법
- 여러 테이블로 분리된 정보를 통합하여 검색 시 유용

<br/>

***SQL***

```sql
select 학생.학생이름
  , 학생.나이
  , 계좌.계좌번호
  , 계좌.잔액
from 학생 inner join 계좌 on 학생.학생번호 = 계좌.학생번호
where 학생.나이 >= 30;
```

<br/>

***SQL(Oracle)***

```sql
select 학생.학생이름
  , 학생.나이
  , 계좌.계좌번호
  , 계좌.잔액
from 학생, 계좌 
where 학생.학생번호 = 계좌.학생번호 and 학생.나이 >= 30;
```

<br/>

- 자연 조인(Nature join: on 사용 x)
  - 두개 이상의 테이블을 하나의 테이블로 결합하는 내부 조인과 매우 유사한 기능
  - 두 테이블에 동일한 이름의 컬럼에 대해 값이 같은 레코드를 결합하는 내부 조인
```sql 
select 컬럼1, 컬럼2, ... 컬럼n
from 테이블1 nature join 테이블2
[where 조건]
```

<br/>

- 셀프 조인
  - 한 테이블이 자기 자신과 조인되는 형태
  - 동일한 이름의 테이블에 대한 조인이므로 반드시 테이블 이름에 대한 별칭이 의무적으로 사용

### 뷰(View)

- 데이터를 저장하고 있는 하나 이상의 테이블을 유도하여 생성하는 가상의 테이블(virtual table)
- `데이터 독립성`: 원본 테이블의 구조가 바뀌어도 뷰를 이용한 작업은 정의만 변경되어 응용프로그램에 영향이 없다.
- `데이터 보안`: 사용자에게 원본 테이블의 일부 컬럼에 대한 접근을 허용하여 보안 효과를 향상시킨다.
- 다양한 구조의 테이블 사용: 사용자의 요구사항에 맞는 테이블의 구조를 제공한다.
- `작업의 단순화`: 복합한 질의 문을 뷰로 단순화한다.
- `데이터 무결성`: with check option 을 이용하여 뷰 생성에 위배되는 수정작업을 거부한다. 테이블이 생성되지는 않지만 테이블처럼 사용 가능하다. 
  
```sql
create view 뷰이름 as 
( select 컬럼1, 컬럼2, ... 컬럼n from 테이블 [where 조건] )
[with check option]
```

<br/>
<hr>

# 7강. 정규화

### 좋은 릴레이션과 나쁜 릴레이션

- 잘못된 데이터베이스 모델링 
  - <img src="/assets/img/knou_database_system/8.png" width="400px"> 
  - 데이터의 부분적인 중복
    - 일관성 유지 어려움.
    - 저장 공간 낭비
  - 갱신 이상
    - 삽입 이상: 레코드 추가 시 불필요한 컬럼의 값이 없이는 추가하지 못 하는 경우
    - 삭제 이상: 삭제 시 의도하지 않았던 다른 데이터가 삭제되는 경우
    - 수정 이상: 중복 저장된 레코드를 수정 시 모두 반영이 안되어 데이터베이스의 일관성이 깨지는 경우.
  
- 좋은 릴레이션의 개념
  - 릴레이션의 스키마가 얼마나 효율적으로 실세계를 반영
  - <img src="/assets/img/knou_database_system/9.png" width="600px"> 
  - 고려사항
    - 한 릴레이션 내의 컬럼 간의 관계 분석
    - 원하지 않는 데이터의 종속과 중복 제거
    - 새로운 컬럼들이 데이터베이스에 추가될 때, 기존 컬럼과 관계 수정을 최소화

### 함수의 종속성

- 정의
  - 릴레이션 인스턴스를 분석하여 속성들 간의 연관관계를 표현한 것
  - 릴레이션의 효율성을 향상시켜 좋은 릴레이션으로 변환하는데 이용되는 중요한 개념
  - <img src="/assets/img/knou_database_system/10.png" width="400px"> 
  - a컬럼의 값이 같으면 b컬럼의 값은 같다. 
  - 등급이 할인율을 종속한다.
  - 등급: 결정자
  - 할인율: 종속자
  
- 함수적 종속성의 확장
  - 함수적 종속성은 릴레이션의 효율성 여부에 중요한 판단기준이다. 
  - 릴레이션의 인스턴스만으로 내재된 모든 함수적 종속성을 찾아내기 어렵다. 
  - 판별되지 않은 모든 함수적 종속성을 찾기 위해 추론 규칙을 사용하여 함수적 종속성을 확장한다. 
  - 클로저(closure)
    - 판별된 함수적 종속성 집합으로부터 유추할 수 있는 모든 함수적 종속성 집합
  
- 함수의 종속성 판별
  - <img src="/assets/img/knou_database_system/8.png" width="400px"> 
  - 결정자                    종속자
  - 고객번호 →                고객명
  - 고객병 →                  등급
  - {고객번호, 고객명} →       할인율
  - 고객번호 →                {고객명, 등급, 할인율}
  
- 암스트롱 공리
  - 재귀 규칙: X ⊇ Y 이면, X → Y
  - 부가 규칙: X → Y 이면, XZ → YZ
  - 이행 규칙: X → Y 이고 Y → Z 이면, X → Z
  - 분해 규칙: X → YZ 이면, X → Y 
  - 합집합 규칙: X → Y 이고, X → Z 이면, X → YZ
  - 의사 이행성 규칙: X → Y 이고, WY → Z 이면, WX → Z 
  
- 카노니컬 커버
  - 함수적 종속성 추런 규칙으로 확장된 클로저에는 자명한 종속성과 중복된 종속성을 포함
  - 불필요한 함수적 종속성을 제거한 표준형으로 변환 후 정규화를 수행

### 정규화

- `정규형`: **이상 현상을 최소화하도록 특정 조건을 갖춘 릴레이션의 형식**
  
- 정규형의 분류
  - 제 1정규형 > 제 2정규형 > 제 3정규형 > BC 정규형 > 제 4정규형 > 제 5정규형
  - (대부분 제 4/5정규형까지 도달하지 않는다.)
  
- `정규화`: **특정 정규형의 조건을 만족하도록 릴레이션과 속성을 재구성하는 과정**
  
- 정규화의 기능
  - 데이터베이스 내 모든 릴레이션을 효과적으로 표현
  - 보다 간단한 관계연산에 기초하여 검색 알고리즘을 효과적으로 작성할 수 있도록 지원
  - 바람직하지 않은 삽입, 수정, 삭제 등의 이상 발생 방지
  - 새로운 형태의 데이터가 삽입될 때 릴레이션 재구성의 필요성을 축소
  
- 제 1정규화
  - 원자성을 만족해야 한다. 
  - `원자성`: 한 컬럼의 값은 하나이어야 한다.
  - <img src="/assets/img/knou_database_system/11.png" width="600px"> 
  
- 제 2정규화
  - 제 1정규화 + 기본키를 제외한 컬럼들은 모두 기본키에 종속
  - <img src="/assets/img/knou_database_system/12.png" width="600px"> 
  - <img src="/assets/img/knou_database_system/13.png" width="600px"> 
  
- 제 3정규화
  - 제 2정규화 + 기본키가 아닌 속성들이 어떤 키에도 이행적 종속성이 없는 하는 상태
  - (기본키를 제외한 컬럼들 중 한 컬럼이 다른 컬럼을 종속하는 경우)
  - <img src="/assets/img/knou_database_system/14.png" width="600px"> 
  
- BC정규화
  - 제 3정규형 + x → y 를 종속한다라는 모든 상태에 대해서 x는 수퍼키여야 한다. 
  - {도크번호, 입항시간} → {목적}
  - {도크번호, 입항시간} → {출항시간}
  - {목적} → {도크번호}: 목적은 기본키가 아님에도불구하고 결정자인 상태(BC정규화 필요)
  - <img src="/assets/img/knou_database_system/15.png" width="600px"> 
  
- 정규형 결과
  - <img src="/assets/img/knou_database_system/16.png" width="600px"> 
  
- ***정리***
  - `정규화`
    - 릴레이션 분할을 통해 `데이터의 중복성을 최소화` 하는 과정
    - 사용 과정에서 많은 `조인 연산 유발`
  - `반정규화`
    - 정규화를 통해 분리되었던 `릴레이션을 통합`하는 재조정을 수행하고 정보의 `부분적 중복을 허용`하는 기법
    - 데이터 접근 성능을 개선 목적

<br/>
<hr>

# 9강. 데이터 저장과 파일

### 물리적 저장장치

- 데이터 접근 속도, 용량을 기준으로 다양한 장치로 구성
- <img src="/assets/img/knou_database_system/17.png" width="600px"> 
- 휘발성
  - 캐시: 고비용 저장장치로 빠른 접근속도 보장
  - 메인 메모리: 실제 프로그램과 데이터 적재 공간
- 비휘발성
  - 자기디스크: 데이터베이스 전체를 안정적으로 저장
  - 플래시 메모리: 메인 메모리와 유사하나 비휘발성
  - 자기 테이프: 용량이 크고 저렴하나 순차 접근 방식으로 접근하여 속도가 매우 느림
  - 광학 디스크: CD, DVD, Blue-ray 등..

### 파일

- 하나의 릴레이션은 여러 개의 블록으로 나뉘어 저장된다. 
- <img src="/assets/img/knou_database_system/18.png" width="600px"> 
- 파일
  - 데이터를 영구적으로 저장하기 위해 사용되는 가장 기초적인 논리적 구조
- 블록 
  - 파일을 고정적인 길이로 분할하여 생기는 균등한 크기의 데이터 묶음
  - 일반적으로 메모리와 디스크 간 데이터 전송 단위로 결정
- 레코드
  - 블록을 구성하는 요소
  - 더 이상 분리될 수 없는 최소 데이터 저장 단위
  
- `고정 길이 레코드`
  - <img src="/assets/img/knou_database_system/19.png" width="400px"> 
  - 모든 레코드가 40byte 크기로 구성될 때, i 번째 레코드 접근
  - (i - 1) * 40 + 1 번째 바이트부터 40개의 바이트를 읽어 접근
- 고정 길이 레코드 할당
  1. 블록의 길이가 레코드 길이로 정확히 나눠지지 않아 잔여 공간을 비워두는 방법
    <img src="/assets/img/knou_database_system/20.png" width="400px"> 
  2. 블록의 길이가 레코드 길이로 정확히 나눠지지 않아 한 레코드를 두 블록에 나누어 저장하는 방법
    <img src="/assets/img/knou_database_system/21.png" width="400px"> 

- 고정 길이 레코드 할당 문제점
  - 레코드 삭제 시 해당 레코드가 저장된 위치에 빈 공간이 생성
  - 장시간 레코드의 삽입 및 삭제 발생 시, 저장 공간에 많은 낭비 발생

- 레코드 삭제시 대처 방안
  - 마지막 레코드로 공백 대체
  - 삭제 레코드 이후의 레코드를 이동
  - 가용 리스트 관리
    - 파일의 헤더에 공백 레코드 포인터를 집어 넣어 특정 행 삭제시, 공백 레코드 포인터가 빈 행에 대한 링크를 가지고 있는다. 새로운 레코드 삽입 시 공백 레코드 포인터를 활용하여 빈 행에 레코드를 삽입한다. (연결 리스트 활용)

- `가변 길이 레코드`
  - 블록에 저장되는 레코드의 길이가 서로 다른(가변적) 레코드를 할당하는 방법
- 가변 길이 레코드가 사용되는 상황
  - 하나의 블록에 두 개 이상의 레코드가 있을 때 
  - 길이가 고정되지 않은 컬럼의 개수가 하나 이상일 때 
  - 레코드가 멀티셋을 허용한 컬럼을 가질 때
  - `멀티셋`: 레코드의 컬럼 값이 여러 개인 컬럼 (원자성에 어긋남)
  - <img src="/assets/img/knou_database_system/22.png" width="400px"> 
  - 해당 행에 대한 정보 + 고정길이 컬럼들 + NULL + 가변길이 컬럼들
  - <img src="/assets/img/knou_database_system/23.png" width="600px">
  - 하나의 블록 내부에 여러 레코드가 쌓이는 가변 길이 레코드는 슬롯 페이지 구조를 사용하며, 레코드가 마지막 공간부터 차곡차곡 쌓인다. 
  
- 파일 구조화: 파일 수준에서 레코드를 관리하는 기법
  
- 파일 구조화 방법의 종류
  - 새로운 행 삽입시, 
    - `힙 파일 구조저장`
      - 순서 고려없이 파일 내 빈 공간 임의의 위치에 저장
      - 가장 빠른 저장속도
      - 좋지 않은 조회성능
    - `순차 파일 구조`
      - 레코드들이 탐색키 기준으로 정렬되어 저장
      - 힙 파일 구조보다는 저장속도가 느림
      - 빠른 조회성능 with `이진 탐색 트리방식`
      - 가장 많이 사용되는 구조
    - `해시 파일구조`
      - 해시 함수를 사용하여 블록 주소를 계산하여 저장
  
- 순차 파일 구조
  - 레코드가 검색키 순서대로 정렬
  - 레코드가 파일에 삽입되는 시점에 키 값이 부여
  
- 순차 파일 구조의 장점
  - 검색키에 대한 정렬 연산이 필요없다. 
  - 현재 레코드에서 정렬된 키 순서로 다음 레코드를 찾을 때 부가적인 블록 접근이 불필요하다.
  - 이진 탐색을 사용하면 더 빠른 레코드 검색이 가능하다. 
- 순차 파일 구조의 단점
  - **레코드 삽입, 삭제에 많은 비용이 소모된다.** 
  
- `오버플로우 블록`
  - 저장의 방식을 개선하기 위해 오버플로우 블록을 사용하기도 한다. 
  - 순차 파일 구조에서 레코드의 정렬된 상태를 유지하기 위해 삽입된 신규 블록

### 저장장치 관리

- 저장장치 접근
  - 파일은 논리적 관점에서의 저장 객체
  - 실제 저장될 때에는 여러 개의 물리적 단위인 블록으로 저장
    - **블록은 메모리와 디스크 간 데이터의 전송 단위**
    - 일반적으로 2KB ~ 32KB 사용
    - **블록 전송을 최소화 할수록 입출력 소요 시간이 단축된다.** 
      - 사용 중인 블록을 지속적으로 메모리에 적재한다.
      - (디스크는 느리니까 한 번 읽은 블록은 여러번 재사용 할 수 있게한다.)
      - 한정적 공간으로 인하여 필요에 따라 특정 블록 할당을 해지한다.  
      - 메모리 내부에 `버퍼`라는 공간에 블록을 저장하고, 이를 관리하기 위해 `버퍼 관리자`를 사용한다.(디스크와 메인 메모리 사이에 버퍼를 두고 버퍼관리자가 관리)
  
- `버퍼관리자`
  1. 소프트웨어가 블록 요청
  2. 버퍼 관리자가 메인 메모리를 탐색하여 블록을 찾아 전달
  3. 블록이 없다면, 디스크로가서 해당 블록을 찾아 메모리에 전달 후 응답
    - 메모리에 블록을 전달 시 메모리의 공간이 꽉 차있을 경우, 메모리 중에 비어있는 데이터를 디스크로 내보내고 필요한 블록을 메모리에 적재한다.
  
- ***메모리의 공간이 꽉 차있을 경우, 버퍼 관리자는 메모리 내 어떤 블록을 비울까?***  
  - 버퍼 교체 전략
    - 가장 쓰임이 덜할 것 같은 블록을 디스크에 보냄(어떤 교체전략이 좋다 이런 것은 없음)
    1. `LRU(Least Recently Used)`: 최근에 가장 적게 사용된 블록을 교체
    2. `MFU(Most Frequently Used)`: 특정 기간동안 가장 여러번 사용된 블록을 교체
  
- `고정 블록과 블록 강제 출력`  
  - **메모리 내 블록을 고정 하여 버퍼관리자에 의해 해당 블록이 나가는 것을 막는다.** 
  - 고정블록
    - 메모리 내 고정되어 있는 블록
  - 블록 강제 출력
    - 메모리 내 블록 중 <u>강제로 디스크에 내보내는 것</u>
    - 메인 메모리는 휘발성이기에 전원이 나가거나 서버연결이 끊길 시 중요한 블록이 소실될 수 있기에 영구저장장치인 디스크로 내보낸다.

<br/>
<hr>

# 10강. 인덱싱

### 인덱싱의 이해

- 블록 요청 → 디스크 내 데이터 메모리 할당 → 응답
- `인덱스`
  - 디스크와 메모리 사이의 입/출력을 줄일 수 있는 기능
  - DBMS에서 요청된 레코드에 빠르게 접근할 수 있도록 지원하는 데이터와 관련된 부가적인 구조
- 인덱싱: 인덱스를 구성하고 생성하는 작업
  
- 인덱스 활용: 인덱스의 탐색키를 이용하여 해당 래코드가 저장된 블록을 디스크 저장장치 / 메모리에서 파악하여 해당 블록을 빠르게 적재한다. 
- `탐색키`: 파일에서 레코드를 찾는데 사용되는 컬럼/컬럼의 집합
  
- 인덱스 기반의 검색 과정
  1. 디스크에 저장된 모든 인덱스 블록을 메모리에 적재(모든 레코드 블록을 한 번에 적재하기는 어렵지만, 인덱스 블록은 메모리가 훨씬 작아 모든 인덱스 블록을 올리기가 가능)
  2. 해당 레코드 블록을 찾아 응답
  
- 인덱스의 종류
  - `순서 인덱스`: 특정 값에 대해 정렬된 순서 구조
  - `해시 인덱스`: 해시 함수를 이용해서 저장에 대한 순서를 결정하는 구조
  
- 인덱스 평가기준
  - 접근시간: 데이터를 찾는데 걸리는 시간
  - 유지비용: 데이터를 삽입/삭제 연산으로 인한 인덱스 구조 갱신 비용
  - 공간비용: 인덱스 구조에 의해서 사용되는 부가적인 공간 비용

### 순서 인덱스

- 순서 인덱스의 특징
  - 탐색 키로 정렬된 순차 파일에 대하여 레코드에 대한 빠른 접근이 가능하도록 구성한 인덱스
  - 탐색 키를 정렬하여 해당 탐색 키와 탐색 키에 대한 레코드와의 연계를 통하여 인덱스 생성(탐색 키가 순차적으로 정렬되어 있다.)
  
- 인덱스 엔트리 구조
  - <img src="/assets/img/knou_database_system/24.png" width="400px">
  - 오프셋: 블록 b2에서 30byte 뒤에 위치
  
- 순서 인덱스 종류
  - 밀집 인덱스
    - <img src="/assets/img/knou_database_system/25.png" width="400px">
    - 모든 레코드에 대해 인덱스 엔트리를 유지하는 인덱스
  - 희소 인덱스
    - <img src="/assets/img/knou_database_system/26.png" width="400px">
    - 인덱스 엔트리가 일부 탐색키 값만을 유지
    - COM31을 찾을 경우 COM31보다 작은 탐색키중 가장 큰 탐색키(COM11)을 통해서 다시 순차적으로 COM11에서부터 데이터를 찾는다.
  - 다단계 인덱스(밀집 인덱스의 밀집인덱스: 밀집인덱스 + 희소 인덱스)
    - <img src="/assets/img/knou_database_system/27.png" width="400px">
    - 밀집 인덱스는 상대적으로 많은 데이터 저장공간을 요하기에 다단계 인덱스가 등장
    - 인덱스 크기 < 메모리 크기: 디스크 I/O이 줄어 탐색시간이 축소된다. 
    - 인덱스 크기 > 메모리 크기: 저장된 블록을 여러번 나누어 읽어야 하기 때문에 디스크 I/O 비용이 증가하여 탐색 시간이 증가한다. 이럴 경우 전체 인덱스에 대한 인덱스를 다시 만들어서 크기를 줄여 활용한다.
    - e.g. 내부 인덱스는 1,000,000개의 블록을 갖는 반면, 외부 인덱스는 100개의 블록만 사용하여 작은 크기의 외부 인덱스로 메모리에 적재 가능

### B+ Tree 인덱스(이진탐색트리를 다단계 인덱스와 결합)


