---
title: "[U-KNOU] 자료구조"
description: "[U-KNOU] 자료구조"
date: 2024-11-12
categories: [ U-KNOU, Data Structure ]
tags: [ U-KNOU, Data Structure ]
---

# ***1강. 자료구조란 무엇인가?***

### 자료와 정보

- 자료
  - 관찰/측정을 통해 수집된 값/사실
  - 물리적인 단위로 표현하여 얻어낼 수 있는 내용
  
- 정보
  - 의사결정을 할 수 있게 하는 지식
  - 자료 상호간의 관계를 표현
  - 자료의 2차 처리 결과물

### 추상화 

- 물리적/전기적인 동작과 무관
- 사람의 상상
- 공통적인 개념 이용. 같은 종류의 다양한 객체 정의(e.g. 버스)

### 자료구조와 알고리즘

- 자료구조
  - 추상화를 통해 알고리즘에서 사용할 자료의 논리적 관계를 구조화
  - 개발자 → 추상화 → 자료구조 ← 구체화 ← 컴퓨터
  - 입력 자료에 대한 추상화
  
- 알고리즘
  - 컴퓨터에게 일을 시키기 위한 추상화된 명령어의 유한 집합
  - 컴퓨터에게 시킬 일을 머릿속에서 추상화 시켜 상상해 놓은 것
  - 컴퓨터가 수행해야 할 명령의 추상화
  
<img src="/assets/img/knou_data_structure/001.jpg" width="400px" />
  
- 추상화
  - 그림/수식 같이 의미를 표현하라고 전달하는 방법
- 추상 자료형
  - 자료구조를 표현하는 가장 대표적인 방법

### 알고리즘 조건

- **출력**: 알고리즘 수행 시 적어도 한 가지 결과를 생성해야 함
- **유효성**: 반드시 실행 가능해야 함
- **입력**: 외부/내부 입력값 유한. 반드시 입력형태가 정의될 수 있어야 함
- **명확성**: 각 명령들은 애매모호 하면 안됨
- **유한성**: 반드시 종료 정의 

### 알고리즘 성능

- 알고리즘의 실행시간 분석
  - 예측 실행시간 추정하여 알고리즘 성능 분석
  - O(n)
    - 알고리즘의 실행 횟수
    - 실행 시간의 유사한 경향에 대한 표현 방법
    - 같은 O(n)을 가진다고 해서 같은 실행 시간을 갖는것을 의미하지 않는다. 
- 알고리즘 실행메모리 분석 
  - 알고리즘 실행 시 필요한 공간을 추정하여 알고리즘의 성능을 분석한다. 
  
- 실행 메모리 예측
  - 공간 복잡도
    - 프로그램 실행시켜 완료하는데 필요한 총 메모리 공간
    - 공간복잡도 = 고정공간 + 가변공간
  
- 알고리즘 성능 측정
  - 컴퓨터가 실제로 프로그램을 실행하는데 걸리는 시간 측정
  - 실행 시간 측정
    - 실행 프로그램 필요
    - 시스템 시계 이용

<hr>

# ***2강. 배열(Array)***

### 배열의 정의

- 배열의 순서는 메모리 공간에서 저장되는 '원소값의 물리적 순서'
- 인데스 원소값의 쌍으로 구성
- 원소들이 모두 같은 자료형, 같은 크기의 기억공간을 가짐
- 인덱스를 이용해 원소값에 직접 접근 가능
- 메모리 주소값: 실제 메모리의 물리적인 위치값

### 배열의 확장

- 2차원 배열
  - 행 우선 배열: 1행부터 메모리 할당
  - 열 우선 배열: 1열부터 메모리 할당

### 희소행렬

- 2차원 배열에서 원소값이 0인 원소가 그렇지 않은 원소보다 상대적으로 많을경우 사용
- 0이 아닌 값만을 따로 모아서 저장
- <img src="/assets/img/knou_data_structure/002.jpg" width="400px" />

<hr>

# ***3강. 스택(Stack)***

### 스택의 개념

- FILO
- 관계를 표현하기 위해 연산 필요
- 객체에 대한 정의, 연산이 모여 순서가 기억되는 스택의 추상 자료형이 완성된다.
- 0개 이상의 원소를 갖는 유한 순서 리스트
- push(): add
- pop(): delete

### 스택의 응용

- 변수에 대한 메모리 할당과 수집을 위한 시스템 스택
- 서브루틴 호출 관리를 위한 스택
- 연산자들 간의 우선순위에 의해 계산 순서가 결정되는 `수식 계산`
- 인터럽트 처리와 되돌아갈 명령 수행 지점을 저장하기 위한 스택
- 컴파일러, 순환 호출 관리

### 사칙연산의 전위/후위/중위 표현

- 중위 표기법: A + B
- 전위 표기법: +AB
- 후위 표기법: AB+
  - (A - ((B + K) / D))
  - (A - ((BK+) / D))
  - (A - ((BK+)D/))
  - (A((BK+)D/))-
  - <img src="/assets/img/knou_data_structure/03.jpg" width="400px" />

<hr>

# ***4강. 큐(Queue)***

### 큐의 개념

- FIFO / FCFS(First Come First Serve)
- 삽입연산과 삭제연산이 다른 곳에서 이뤄진다.
- `front`: 큐의 제일 앞 원소가 담긴 공간을 가르킨다.
- `rear`: 큐의 제일 뒤 원소가 담긴 공간을 가르킨다.
- <img src="/assets/img/knou_data_structure/04.jpg" width="400px" />
- <img src="/assets/img/knou_data_structure/05.jpg" width="400px" />

### 큐의 추상 자료형

- 큐 객체: 0개 이상의 원소를 갖는 유한 순서 리스트
- <img src="/assets/img/knou_data_structure/08.jpg" width="400px" />
- <img src="/assets/img/knou_data_structure/06.jpg" width="400px" />
- <img src="/assets/img/knou_data_structure/07.jpg" width="400px" />

### 큐의 응용

- CPU 관리 방법
  - FCFS 스케줄링
    - 준비 큐에 도착한 순서대로 CPU 할당
  - RR 스케줄링
    - 정해진 일정 시간동안만 CPU 할당

### 배열을 이용한 큐의 구현

```C
#define QUEUE_SIZE 5
typedef int element;
element queue[QUEUE_SIZE];
  int front = -1;
  int rear = -1;
```

- <img src="/assets/img/knou_data_structure/09.jpg" width="400px" />
- <img src="/assets/img/knou_data_structure/10.jpg" width="400px" />

### 원형 큐

- 배열로 구현한 큐의 경우, 큐의 원소의 개수가 n-1 이 아니더라도 큐가 full이 될 수 있다. 
  - <img src="/assets/img/knou_data_structure/11.jpg" width="400px" />
  
- 배열의 문제점을 해결하기 위해 원형 큐 제안
- 연결된 부분의 데이터 공간을 연속적으로 사용하기 위해 `나머지 연산자`를 활용한다. 
  - <img src="/assets/img/knou_data_structure/12.jpg" width="600px" />
  > 해당 원형 큐에 600 원소값을 넣을 때  
  > rear + 1 % QUEUE_SIZE = 0 이므로 인덱스 0에다 삽입가능

<hr>

# ***5강. 연결 리스트***

- 배열을 이용한 리스트 구현
  - 빈번한 자료 이동으로 인해 실행 성능에서 비효율
- 포인터를 이용한 리스트 구현
  - 노드: 원소값을 가리키는 정보의 자리
    - 원소값
    - 포인터(링크)
        ```c
        int a = 100;
        int *b;       // *: 포인터 변수 선언
        b = &a;       // &: 역참조 연산자(a의 주소값을 반환한다.)

        printf("a is %d\n", a); // a is 100
        printf("*b is %d\n", b);// *b is 100

        int a;
        int *p_a;
        p_a = &a;   // p_a에 변수 a의 주소 저장
        a = 231;    
        *p_a = 521; // p_a가 지시하고 있는 주소(a의 주소)를 찾아서 521 저장.(a == 521이 된다.)
        ```
          
- 구조체(struct): 다양한 데이터형을 하나의 단위로 다룰 수 있다. 
  - e.g. 노드(원소값 + 포인터)
    ```c
    struct linked_list_node {
      int data;
      struct linked_list_node *link;
    }
    ```
  
- malloc(): 동적으로 필요한 만큼의 메모리 공간을 할당받게 해준다.  

<hr>

# ***6강. 연결 리스트 응용***

- 단순 연결 리스트
  - 링크 1개. 각 노드는 후행 노드를 가르킨다.
  - 특정 노드의 선행 노드에 대한 접근은 헤드 노드로부터 재검색해야 가능하다.
- 이중 연결 리스트
  - 링크 2개. 각 노드는 선행노드, 후행노드를 가르킨다.
  - 리스트 원소들의 역순 검색 편리성 
- 원형 연결 리스트  
  - 각 단말 노드의 링크 값 null을 첫 번째 노드 링크 값으로 변경

<hr>

# ***7강. 트리***

<img src="/assets/img/knou_data_structure/Tree.png" width="600px" />

- 트리
  - 데이터의 계층 관계, 포함 관계 등을 나타내는 자료구조
  - 데이터 분류시 많이 사용
- 노드(정점): 트리를 구성하는 항목
- 루트: 트리에서 부모를 갖지 않는 노드
- 진입차수
  - 트리 내 특정 노드에 대해 그 노드로 들어오는 선의 개수
  - 루트를 제외한 모든 노드의 진입 차수는 1이다. (2 이상인 경우 그래프)
- 진출차수: 트리 내 특정 노드에 대해 그 노드에서 나가는 선의 개수
- 트리의 차수: 트리 안에 있는 각 노드의 차수 가운데 최대 차수로 정의
- 내부노드: !루트노드 & !단말노드
- 형제: 같은 부모를 갖는 노드들
  
- 이진트리
  - 트리에 속한 모든 노드의 차수가 2 이하인 트리
  - 전 이진 트리(full)
    - 모든 노드가 0 또는 2개의 자식을 갖는 트리
  - 가득 찬 이진트리(perfect)
    - 모든 내부 노드는 2개의 자식을 갖으며 모든 잎의 레벨은 같다.
  - 완전 이진 트리(complete)
    - 단말 노드들이 왼쪽부터 채워진 트리
- 이진 트리 구현
  - 연속된 배열로 구현: 트리가 깊어질 수록 2의 거듭제곱에 비례하여 기억장소 낭비
  - 연결 리스트로 구현
  
- 순회(traverse)
  - 트리의 각 노드를 빠짐없이 한 번씩만 방문하는 것
  - <img src="/assets/img/knou_data_structure/tree1.png" width="400px" />
  - 전위 순회(PLR)
    - J → A → M → aM → V → P → C → Pi → Sh → Sc → E → N 
  - 중위 순회(LPR)
    - aM → M → V → A → c → P → Pi → J → Sh → E → Sc → N
  - 후위 순회(LRP)
    - aM → V → M → C → Pi → P → A → E → N → Sc → Sh → J

<hr>

# ***8강. 스레드 트리***

- 스레드: 정해진 순회 방법에 따른 방문 순서를 유지하는 포인터
  - 왼쪽: 선행 노드를 가리킴
  - 오른쪽: 후행 노드를 가리킴
- 스레드 트리
  - 스레드라는 포인터를 갖는 이진 트리
  - 이진 트리는 순회시 방문하지 않고 지나쳐 온 노드는 스택에 저장하는데, 이러한 번거로움 을 없앤 트리
- 스레드 구현 2가지 방법
  - 스레드를 저장하는 포인터 추가하는 방법
    - 왼쪽 스레드 포인터, 왼쪽 자식 포인터, 데이터, 오른쪽 자식 포인터, 오른쪽 스레드 포인터
  - 연결 리스트 노드 구조를 사용하면서 단말 노드에 있는 빈 포인터 활용하는 방법
    - 플래그(flag): 스레드와 서브트리 포인터를 구분. 기억장소 낭비 방지

<hr>

# ***9강. 힙***

- 힙(heap)
  - 피라미드 모양으로 쌓아 올린 더미
  - 부모 노드와 자식 노드 사이에 일정한 대소관계를 정의
  - 부분적으로 정렬된 완전 이진 트리
    - 힙: 완전 이진 트리: 기억 장소 낭비 x: 배열 구현 적합
  - 삽입, 삭제가 매우 쉽다.
  - 우선 순위 관리 응용에 사용된다.
  - 데이터 정렬에 사용된다.
  - 우선순위 큐를 트리로 구현
  - <img src="/assets/img/knou_data_structure/heap1.png" width="600px" />
    - 삭제 함수 실행시, 저장된 데이터 중 우선 순위가 가장 높은 값이 반환 후 삭제
  - 노드 삽입
    - 제일 마지막 노드에 삽입하여 순차적으로 올라간다. 
- 최대힙: 부모노드 > 자식노드
- 최소힙: 부모노드 < 자식노드

<hr>

# ***10강. 선택 트리, 숲, 이진 트리 개수***

- 합병 정렬
  - 차례로 정렬한 데이터 리스트 k개를 완전한 순서를 유지하는 하나의 리스트로 만드는 과정
- 선택 트리: 합병 정렬에 사용되고 비교 횟수를 줄인다. 
  - 승자 트리: 노드 비교 시 작은 값이 부모노드가 된다. 
  - 패자 트리: 단말 노드 비교 시 큰 값이 부모노드(패자노드)가 되며, 다음 비교 시 승자 노드로 비교한다. 

- <img src="/assets/img/knou_data_structure/tree2.png" width="400px" />
- 승자 트리
  - <img src="/assets/img/knou_data_structure/tree3.png" width="500px" />
  - <img src="/assets/img/knou_data_structure/tree4.png" width="500px" />
- 패자 트리
  - <img src="/assets/img/knou_data_structure/tree5.png" width="500px" />
  - <img src="/assets/img/knou_data_structure/tree6.png" width="500px" />
  
- 숲: 분리된 트리 모임
- 숲의 이진 트리 변환
  - 각 트리를 이진트리로 변경 후 하나의 이진트리로 구성한다. 
  - 각 트리를 이진트리로 변경할 때, 로트는 왼쪽 서브트리만 갖는다.
  
- 노드 n개인 서로 다른 이진 트리의 개수
  - (2n)! / n!(n+1)!

<hr>

# ***11강. BS, Splay, AVL, BB***

- 이진 탐색 트리(BS Tree: Binary Search Tree)
  - 삽입, 삭제 연산 효과적으로 작업
  - 노드를 식별하기 위한 키 사용
  - 탐색: 탐색 성공 시 해당 키 값이 아니라 노드를 반환
  - 삽입: 새 노드는 항상 잎으로 삽입
  - 삭제
    - <img src="/assets/img/knou_data_structure/tree7.png" width="400px" />
    - F 삭제시, 왼쪽 서브트리의 가장 큰 값 E, 혹은 오른쪽 서브트리의 가장 작은 값 G가 F자리에 대체 가능
    - 삭제 시 복잡한 과정을 피하려면 그냥 삭제할 노드를 삭제한 것으로 표시하고 트리에 내버려 둔다.
- 트리의 높이: 루트부터 잎까지 가장 긴 경로의 길이
- 트리의 무게: 트리에 속한 단말 노드의 개수

- 휴리틱스(heuristic) 알고리즘을 사용한 BS트리<span style="color:red;">(아직 재구성 방식을 이해 못하여 다시 한 번 볼것!)</span>
  - Splay
    - 자주 탐색하는 키를 가진 노드를 루트에 가깝게 위치
    - Splay 연산을 적용하여 트리 재구성
  - AVL
    - 왼쪽/오른쪽 서브트리의 높이가 1만큼 차이나는 트리
    - 삽입/삭제 시 O(log2 N)
  - BB(Bound-Balanced Tree)
    - 양쪽 서브트리의 무게가 같음

<hr>

# ***12강. 멀티웨이 탐색 트리 1<span style="color:red;">(재복습 필요)</span>***

- 멀티 웨이 탐색 트리
  - m원 탐색 트리: 이진 탐색 트리 확장
    - 트리의 노드가 m개 이하의 가지를 가질 수 있는 탐색 트리 
    - 파일의 인덱스를 구현할 경우 특정 레코드를 빠르게 참조
    - 중첩 구조체로 정의
        ```c
        struct Mnode {
          int n;
          struct rectype {
            struct Mnode *ptr;
            int key;
            struct Rectype *addr;
          } keyptrs[n-1];
          struct Mnode *keyptrn;
        }
        ```
    - B 트리
      - 차수 m인 B트리 정의
        - 루트와 단말 노드를 제외한 트리의 각 노드는 최소 m/2개의 서브트리를 갖는다. 
        - 트리의 루트는 최소한 두 개의 서브트리를 갖는다. 
        - 트리의 모든 잎은 같은 레벨에 있다. 
      - 삽입, 삭제(교재 p.260 ~ p.266 참조)
    - B* 트리
      - 노드의 약 2/3 이상이 차야하는 B트리
      - 노드가 꽉 차면 분리하지 않고 키와 포인터를 재배치하여 다른 형제 노드로 옮긴다.
    - B+ 트리
      - 인덱스된 순차 파일을 구성하는데 사용
        - 데이터를 차례로 처리하는 순차처리
        - 특정 데이터를 직접 찾아 처리
      - **잎 노드를 순차적으로 연결하는 포인터 집합 존재**
  
<hr>

# ***13강. 멀티웨이 탐색 트리 2(<span style="color:red;">재복습 필요</span>)***

- 2-노드: 차수가 2인 노드
- 3-노드: 차수가 3인 노드
- 2-3 트리
  - 2-노드와 3-노드로만 구성한 트리
  - B 트리 계열과 거의 같은 성능을 유지하면서 상대적으로 삽입, 삭제가 용이하다. 
- 2-3-4 트리: 2-노드, 3-노드, 4-노드로만 구성한 트리
- 레드 블랙 트리
  - 2-3-4 트리를 이진 트리로 나타낸 것
  - 기억장소를 효율적으로 사용
  - 두 종류의 서브트리 포인터
    - 레드 간선: 2-3-4 트리의 한 노드 내 있던 항목
    - 블랙 간선: 2-3-4 트리의 포인터

<hr>

# ***14강. 그래프 1***

- 정점 집합 V와 간선 집합 E에 대한 그래프는 G = (V , E)로 나타낸다. 
  - 정점: 그래프를 구성하는 대상
  - 간선: 그래프에 있는 대상들의 관계
- 그래프
  - 방향 그래프
  - 무방향 그래프
  - 양방향 그래프
- 다중 그래프: 두 정점 사이에 두 개 이상의 간선을 허용하는 그래프
- 가중 그래프: 간선이 가중치를 갖는 그래프
- 독립 정점
  - 다른 어떤 정점과도 인접하지 않은 정점
  - 독립 정점만으로 구성한 그래프는 null 그래프가 된다. 
- 사이클: 시작점과 끝점이 같은 경로
- 무사이클 그래프(dag) == 트리
  
- <img src="/assets/img/knou_data_structure/graph1.png" width="600px" />
  - p: 경로: 간선의 집합
  - 루프: 시작점과 끝점이 같은 정점인 길이가 1인 경로
  - 단순경로: p1 ~ p4 
  - 단순경로x: p5 ~ p6
    - 루프 존재
    - 오가는 간선 존재
  
- 그래프 표현법
  - 인접 행렬에 의한 그래프 표현
    - **임의의 두 정점 vi, vj를 연결하는 간선이 존재하는지를 나타낸다.** 
    - 이진 행렬(부울 행렬): 원소들이 0 이거나 1인 행렬
  - 인접 리스트에 의한 그래프 표현<span style="color:red;">(인접 리스트 그림에 대한 이해 필요)</span>
  - 정점 개수 > 간선 개수 일 경우, 연결 리스트로 나타내야 효율적이다. 

<hr>

# ***15강. 그래프 2***

- 그래프 순회: 그래프 내 모든 정점을 빠짐없이, 중복 없이 돌아다니는 것
  - 깊이 우선 탐색(스택)
    - <img src="/assets/img/knou_data_structure/graph2.png" width="600px" />
  - 너비 우선 탐색(큐)
    - 모든 형제를 먼저 방문
    - <img src="/assets/img/knou_data_structure/graph3.png" width="600px" />
    - 4 → 8 → 2 → 7 → 6 → 5 → 1 → 3
  
- 최소 신장 트리
  - **모든 정점**과 간선의 일부 혹은 전부를 포함하는 트리
  - 최소한의 간선으로 연결한 그래프(n-1)
  - 최소 부분 그래프: 그래프 중에서 간선의 수가 가장 작은 것
  
- 최소 비용 신장 트리를 구하는데 사용되는 알고리즘
  - 프림 알고리즘
    - 최소 비용을 갖는 간선을 차례로 추가하는 방법으로 트리 구축
    - 하나의 시작 정점에서 출발하여, 인접한 간선 중 가장 가중치가 작은 간선을 선택하면서 트리를 확장하는 방식으로 진행
    - 우선순위 큐(주로 힙 자료구조)를 활용
  - 크루스컬 알고리즘
    - 남은 간선 중에서 무조건 최소 비용인 간선을 선택한 후 사이클을 형성하지 않으면 그 간선을 선택한다. 
  - 솔린 알고리즘
    - 각 단계마다 다수의 간선을 선택
    - 간선이 하나도 없는 그래프의 모든 정점들로 구성된 숲에서 시작한다. 