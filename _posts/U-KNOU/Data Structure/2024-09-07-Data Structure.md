---
title: "[U-KNOU] 자료구조"
description: "[U-KNOU] 자료구조"
date: 2024-09-07
categories: [ U-KNOU, Data Structure ]
tags: [ U-KNOU, Data Structure ]
---

# 1강. 자료구조란 무엇인가?

### 자료와 정보

- 자료
  - 관찰/측정을 통해 수집된 값/사실
  - 물리적인 단위로 표현하여 얻어낼 수 있는 내용
  
- 정보
  - 의사결정을 할 수 있게 하는 지식
  - 자료 상호간의 관계를 표현
  - 자료의 2차 처리 결과물

### 추상화 

- 물리적/전기적인 동작과 무관
- 사람의 상상
- 공통적인 개념 이용. 같은 종류의 다양한 객체 정의(e.g. 버스)

### 자료구조와 알고리즘

- 자료구조
  - 추상화를 통해 알고리즘에서 사용할 자료의 논리적 관계를 구조화
  - 개발자 → 추상화 → 자료구조 ← 구체화 ← 컴퓨터
  - 입력 자료에 대한 추상화
  
- 알고리즘
  - 컴퓨터에게 일을 시키기 위한 추상화된 명령어의 유한 집합
  - 컴퓨터에게 시킬 일을 머릿속에서 추상화 시켜 상상해 놓은 것
  - 컴퓨터가 수행해야 할 명령의 추상화
  
<img src="/assets/img/knou_data_structure/001.jpg" width="600px" />
  
- 추상화
  - 그림/수식 같이 의미를 표현하라고 전달하는 방법
- 추상 자료형
  - 자료구조를 표현하는 가장 대표적인 방법

### 알고리즘 조건

- **출력**: 알고리즘 수행 시 적어도 한 가지 결과를 생성해야 함
- **유효성**: 반드시 실행 가능해야 함
- **입력**: 외부/내부 입력값 유한. 반드시 입력형태가 정의될 수 있어야 함
- **명확성**: 각 명령들은 애매모호 하면 안됨
- **유한성**: 반드시 종료 정의 

### 알고리즘 성능

- 알고리즘의 실행시간 분석
  - 예측 실행시간 추정하여 알고리즘 성능 분석
  - O(n)
    - 알고리즘의 실행 횟수
    - 실행 시간의 유사한 경향에 대한 표현 방법
    - 같은 O(n)을 가진다고 해서 같은 실행 시간을 갖는것을 의미하지 않는다. 
- 알고리즘 실행메모리 분석 
  - 알고리즘 실행 시 필요한 공간을 추정하여 알고리즘의 성능을 분석한다. 
  
- 실행 메모리 예측
  - 공간 복잡도
    - 프로그램 실행시켜 완료하는데 필요한 총 메모리 공간
    - 공간복잡도 = 고정공간 + 가변공간
  
- 알고리즘 성능 측정
  - 컴퓨터가 실제로 프로그램을 실행하는데 걸리는 시간 측정
  - 실행 시간 측정
    - 실행 프로그램 필요
    - 시스템 시계 이용

<hr>

# 2강. 배열(Array)

### 배열의 정의

- 배열의 순서는 메모리 공간에서 저장되는 '원소값의 물리적 순서'
- 인데스 원소값의 쌍으로 구성
- 원소들이 모두 같은 자료형, 같은 크기의 기억공간을 가짐
- 인덱스를 이용해 원소값에 직접 접근 가능
- 메모리 주소값: 실제 메모리의 물리적인 위치값

### 배열의 확장

- 2차원 배열
  - 행 우선 배열: 1행부터 메모리 할당
  - 열 우선 배열: 1열부터 메모리 할당

### 희소행렬

- 2차원 배열에서 원소값이 0인 원소가 그렇지 않은 원소보다 상대적으로 많을경우 사용
- 0이 아닌 값만을 따로 모아서 저장
- <img src="/assets/img/knou_data_structure/002.jpg" width="600px" />

<hr>

# 3강. 스택(Stack)

### 스택의 개념

- FILO
- 관계를 표현하기 위해 연산 필요
- 객체에 대한 정의, 연산이 모여 순서가 기억되는 스택의 추상 자료형이 완성된다.
- 0개 이상의 원소를 갖는 유한 순서 리스트
- push(): add
- pop(): delete

### 스택의 응용

- 변수에 대한 메모리 할당과 수집을 위한 시스템 스택
- 서브루틴 호출 관리를 위한 스택
- 연산자들 간의 우선순위에 의해 계산 순서가 결정되는 `수식 계산`
- 인터럽트 처리와 되돌아갈 명령 수행 지점을 저장하기 위한 스택
- 컴파일러, 순환 호출 관리

### 사칙연산의 전위/후위/중위 표현

- 중위 표기법: A + B
- 전위 표기법: +AB
- 후위 표기법: AB+
  - (A - ((B + K) / D))
  - (A - ((BK+) / D))
  - (A - ((BK+)D/))
  - (A((BK+)D/))-
  - <img src="/assets/img/knou_data_structure/03.jpg" width="600px" />

<hr>

# 큐(Queue)

### 큐의 개념

- FIFO / FCFS(First Come First Serve)
- 삽입연산과 삭제연산이 다른 곳에서 이뤄진다.
- `front`: 큐의 제일 앞 원소가 담긴 공간을 가르킨다.
- `rear`: 큐의 제일 뒤 원소가 담긴 공간을 가르킨다.
- <img src="/assets/img/knou_data_structure/04.jpg" width="600px" />
- <img src="/assets/img/knou_data_structure/05.jpg" width="600px" />

### 큐의 추상 자료형

- 큐 객체: 0개 이상의 원소를 갖는 유한 순서 리스트
- <img src="/assets/img/knou_data_structure/08.jpg" width="400px" />
- <img src="/assets/img/knou_data_structure/06.jpg" width="600px" />
- <img src="/assets/img/knou_data_structure/07.jpg" width="600px" />

### 큐의 응용

- CPU 관리 방법
  - FCFS 스케줄링
    - 준비 큐에 도착한 순서대로 CPU 할당
  - RR 스케줄링
    - 정해진 일정 시간동안만 CPU 할당

### 배열을 이용한 큐의 구현

```C
#define QUEUE_SIZE 5
typedef int element;
element queue[QUEUE_SIZE];
  int front = -1;
  int rear = -1;
```

- <img src="/assets/img/knou_data_structure/09.jpg" width="600px" />
- <img src="/assets/img/knou_data_structure/10.jpg" width="600px" />

### 원형 큐

- 배열로 구현한 큐의 경우, 큐의 원소의 개수가 n-1 이 아니더라도 큐가 full이 될 수 있다. 
  - <img src="/assets/img/knou_data_structure/11.jpg" width="600px" />
  
- 배열의 문제점을 해결하기 위해 원형 큐 제안
- 연결된 부분의 데이터 공간을 연속적으로 사용하기 위해 `나머지 연산자`를 활용한다. 
  - <img src="/assets/img/knou_data_structure/12.jpg" width="600px" />
  > 해당 원형 큐에 600 원소값을 넣을 때  
  > rear + 1 % QUEUE_SIZE = 0 이므로 인덱스 0에다 삽입가능

<hr>

# 5강. 연결 리스트

- 배열을 이용한 리스트 구현
  - 빈번한 자료 이동으로 인해 실행 성능에서 비효율
- 포인터를 이용한 리스트 구현
  - 노드: 원소값을 가리키는 정보의 자리
    - 원소값
    - 포인터(링크)
        ```c
        int a = 100;
        int *b;       // *: 포인터 변수 선언
        b = &a;       // &: 역참조 연산자(a의 주소값을 반환한다.)

        printf("a is %d\n", a); // a is 100
        printf("*b is %d\n", b);// *b is 100

        int a;
        int *p_a;
        p_a = &a;   // p_a에 변수 a의 주소 저장
        a = 231;    
        *p_a = 521; // p_a가 지시하고 있는 주소(a의 주소)를 찾아서 521 저장.(a == 521이 된다.)
        ```
          
- 구조체(struct): 다양한 데이터형을 하나의 단위로 다룰 수 있다. 
  - e.g. 노드(원소값 + 포인터)
    ```c
    struct linked_list_node {
      int data;
      struct linked_list_node *link;
    }
    ```
  
- malloc(): 동적으로 필요한 만큼의 메모리 공간을 할당받게 해준다.  
